public static void Star()
	{
//				*      
//			  * * *    
//			* * * * *  
//		  * * * * * * *
		long start = System.nanoTime();
		for (int i = 1; i <= 4; i++) {
			for (int j = 1; j <= 7; j++) {
				if (j <= (4 - i) || (8 - j) <= (4 - i)) {
					System.out.print(" ");
				} else {
					System.out.print("*");
				}
				if (j != 7) {
					System.out.print(" ");
				}
			}
			System.out.println();
		}
		long end = System.nanoTime();
		System.out.println("Test1 : " + (end - start) * 1e-9 + " sec.");
		System.out.println();
		//다른 방법1 - 열의 가운데까지 찍고 오른쪽에 나머지 별을 찍는다.
//		    *      
//		  * *		+		 *    
//		* * *		+		 * *  
//	  * * * *		+		 * * *
		//이렇게 하면 열의 가운데를 기준으로 오른쪽은 별이 없는 부분은 안찍어도 되지만, 조건문이 복잡해진다.
		//또한, 내부 반복문이 첫 번째 else절의 조건은 위의 if절에서 구현이 가능하기 때문에 불필요하다.
		start = System.nanoTime();
		for (int i = 1; i <= 4; i++) {
			for (int j = 1; j <= 7; j++) {
				if (j <= 4) {
					if (j >= 5 - i) {
						System.out.print("*");
					} else {
						System.out.print(" ");
					}
				} else {
					if (j <= 4 + (i - 1)) {
						System.out.print("*");
					}
				}
//				System.out.print("*");
				if (j != 7) {
					System.out.print(" ");
				}
			}
			System.out.println();
		}
		end = System.nanoTime();
		System.out.println("Test1 : " + (end - start) * 1e-9 + " sec.");
		System.out.println();
		//다른 방법2 - 열의 가운데까지 찍고 오른쪽에 나머지 별을 찍는다.
		//대신, 내부 반복문 한 개에서 처리하는 것이 아니라 먼저 별을 안 찍는 내부 반복문1을 수행한 후 별을 찍는 내부 반복문2를 순차 수행하도록 한다.
		//열1부터 살펴보면, 별이 안 찍히는 부분이 먼저 오고, 그 후에 별이 찍히게 때문에 내부 반복문 1, 2로 나누는 것이다.
		start = System.nanoTime();
		for (int i = 1; i <= 4; i++) {
//			for (int j = 1; j <= 7;) { //종료 조건을 상수로 확정짓는 것이 아닌
			for (int j = 1; j <= 4 - i; j++) {
				System.out.print(" ");
				System.out.print(" ");
			}
			for (int j = 4 - i + 1; j <= 4 + (i - 1); j++) { //j값을 별이 찍힐 열의 인덱스로 생각하여 이런 식으로 조건을 주거나
//			for (int j = 0; j < i * 2 + 1; j++) { //아니면, j값을 행에 찍힐 별의 개수로 생각하여 이런 식으로 조건을 줄 수도 있다.
				System.out.print("*");
				System.out.print(" ");
			}
			System.out.println();
		}
		end = System.nanoTime();
		System.out.println("Test1 : " + (end - start) * 1e-9 + " sec.");
		
		
//		        *      
//		      * * *    
//		    * * * * *  
//		  * * * * * * *
//		    * * * * *  
//		      * * *    
//		        *      
		for (int i = 1; i <= 7; i++) {
			for (int j = 1; j <= 7; j++) {
				int nIdxFromCenterRow = 4 - i;
				if (nIdxFromCenterRow < 0) {
					nIdxFromCenterRow = -nIdxFromCenterRow;
				}
				if (j <= nIdxFromCenterRow || (8 - j) <= nIdxFromCenterRow) {
					System.out.print(" ");
				} else {
					System.out.print("*");
				}
//				System.out.print("*");
				if (j != 7) {
					System.out.print(" ");
				}
			}
			System.out.println();
		}
	}

# java-junior
1544. Make The String Great

1. 인접한 알파벳이 각각 대소문자로 같은 알파벳인지 확인
 - 방법 :
  1. 비교할 알파벳을 toUpperCase() or toLowerCase()를 통해 같은 알파벳인지 판별 >> 같은 알파벳일지라도 대소문자가 변환되어 같은 것인지 변환되지 않고 모두 대문자 혹은 소문자로 같은 것인지 판별(변환 전 값과 변환 후 값 비교가 필요)
  2. 알파벳의 아스키 코드 값으로 알파벳 종류와 대소문자를 판별 + 같은 알파벳의 아스키 코드 값 차이는 32로 동일하므로 인접한 알파벳 아스키 코드 값 차이가 32인지 확인
 - 인접한 알파벳을 비교하는 방법
  1. for문
 
2. 같은 알파벳일 경우 두 알파벳을 문자열에서 제거
 - 방법 :
  1. String.substring한 값을 다시 String에 대입
  2. List에 제거 대상이 아닌 알파벳을 add하여 결과 값을 String으로 만듦(for문 필요)

*시나리오를 나눌 수 있는 방법
Input: s = "abBAcC"
Output: ""
Explanation: We have many possible scenarios, and all lead to the same answer. For example:
"abBAcC" --> "aAcC" --> "cC" --> ""
"abBAcC" --> "abBA" --> "aA" --> ""
 - 인접한 알파벳을 비교하는 방향을 어디에서부터 찾아나가는지에 따라 시나리오가 나뉘는 것으로 보인다. 방법의 차이는 아니라고 생각한다.

테스트 결과
 - 실패 1
  원인 : 문자열 제거 후 남은 앞의 알파벳과 뒤의 알파벳을 비교하는 로직을 고려하지 않았다. 즉, 현재 로직으로는 비교하고자 하는 알파벳이 통과할 경우 문자열 제거 후 새롭게 인접하게 된 알파벳과 새로 비교하는 로직이 누락되어 있다.
   - 방법 :
    1. 알파벳을 비교하는 for문을 완료한 후 알파벳이 제거된 새로운 결과가 나올 경우 다시 비교 for문을 수행한다. >> 문제 : 제거가 계속 수행되는 for문일 경우 반복문 수행을 계속 호출할 필요가 있는 재귀의 시간 복잡도를 갖게 된다.
	2. 문자열 제거가 일어난 시점에 새로 인접하게 될 두 알파벳을 비교한다.
	 2.1. i와 i+1의 알파벳이 제거됐을 경우 해당 시점의 i-1과 i+2를 비교한다. >> 문제 : 인접하게 될 알파벳이 계속해서 제거가 필요한 경우 마찬가지로 재귀의 시간 복잡도를 갖게 된다.
	 2.2. 문자열 제거 후 앞 문자열과 뒤 문자열을 합쳐 리턴한 문자열 s에서 제자리로 돌아와 반복문을 수행하는 것이 아닌 하나 이전의 인덱스에서 다시 비교를 시작한다. >> 반복문 수행 횟수는 경우에 따라 무한으로 늘어날 수 있지만 중첩이 아닌 단일한 반복문을 수행하므로 복잡도를 낮출 수 있을 것이다.
   
class Solution {
	public String makeGood(String s) {
		for (int i = 0; i <= s.length() - 2; i++) {
			char[] ca = s.toCharArray();
			int nAsciiCodeDiffVal = (char)ca[i] - (char)ca[i + 1];
			//수정1
			//굳이 char 배열 변수를 할당할 필요가 있을까?
//			nAsciiCodeDiffVal = s.substring(i, i + 1) - s.substring(i + 1, i + 2);
			//char 배열이 더 효율적으로 보임
			//아스키 코드 값으로 변환하기 위해서는 char형변환이 필요하며, substring의 경우 인덱스 오류 방지를 위해 조건문이 추가로 필요할 것으로 보이기 때문이다.
			if (nAsciiCodeDiffVal == 32 || nAsciiCodeDiffVal == -32) {
				//substring 인덱스 오류 방지
				String sFront = i == 0 ? "" : s.substring(0, i);
				String sBack = i == s.length() - 2 ? "" : s.substring(i + 2);
				//s에 다시 초기화하여도 새로운 s에 대해 새로운 인덱스로 반복문을 수행하기 때문에 새로운 변수에 할당할 필요가 없다.
				s = sFront + sBack;
//				System.out.println("i : " + i + ", s : " + s);
				//자른 문자열에 대해 현재 인덱스에서 다시 한 번 로직 수행
				//수정1
				//새로 인접할 알파벳(자르고 남은 앞 문자열의 마지막 알파벳과 뒷 문자열의 첫 알파벳) 간의 비교를 위해 한 칸 앞의 인덱스에서 다시 비교를 시작한다.
				//문자열 s의 첫 알파벳일 경우에는 앞 문자열이 없으므로 제자리로 돌아간다.
				i = i == 0 ? i - 1 : i - 2;
			}
		}
		
		return s;
	}
}


1. Two Sum
해석 : 주어지는 값은 정수 배열인 nums와 정수인 target.
결과는 인덱스를 반환하며, 해당 인덱스에 위치한 숫자를 합했을 때 target 값이 되도록하는 결과 값을 찾는다.
솔루션은 하나만 존재한다고 가정하며, 동일한 요소를 두 번 사용할 수는 없다.

제약 사항:
2 <= nums.length <= 104
-109 <= nums[i] <= 109
-109 <= target <= 109
Only one valid answer exists.

방법
1. nums 배열에서 두 요소를 추출한 경우의 수에서 그 합이 target 값과 일치하는 결과를 찾는다.
 - nums.length 최대값은 104로 최대 경우의 수는 104*103의 중첩 반복문이 발생할 수 있다.

2. 어떠한 두 수를 더해 target 값이 되는 경우의 수에서 해당 두 수가 nums 배열 요소로 존재하는지를 찾는다.
 - -109 <= target <= 109이 target의 범위
 target 최소값 -109는 nums[i] 범위에 따라 최소 -109와 최대 0의 범위 내의 수의 합
            -108은 최소 -109와 최대 1의 범위 내의 수의 합
			...
			0은 최소 -109와 최대 109의 범위 내의 수의 합
		최대값 109는 최소 0과 최대 109의 범위 내의 수의 합으로 만들어진다.
 따라서 target이 0이 될 때 두 수의 경우의 수가 최대가 되며, 경우의 수는 -109+109부터 0+0까지 110가지이다.
 하지만, target의 경우의 수를 도출할 시작과 끝이 target 값에 따라 변동되어 반복 조건을 거는 것이 쉽지 않다.
 
흐름도(순서도)를 생각해 보자!
조건 : nums[i] + nums[j] = target?
 - Yes : return [i, j] or [j, i]
 - No : 조건문 재실행(반복)
 
조건문에 대입할 i와 j를 추출하는 방법
1. 일단 nums 배열에서 i와 j를 추출할 수 있는 모든 경우의 수로 작성해보자.

A really brute force way would be to search for all possible pairs of numbers but that would be too slow. Again, it's best to try out brute force solutions for just for completeness. It is from these brute force solutions that you can come up with optimizations.
So, if we fix one of the numbers, say x, we have to scan the entire array to find the next number y which is value - x where value is the input parameter. Can we change our array somehow so that this search becomes faster?
The second train of thought is, without changing the array, can we use additional space somehow? Like maybe a hash map to speed up the search?

public static void ComplementNumber()
	{
		int[] nums = {2, 7, 11, 15};
		int target = 9;
		
		long start = System.nanoTime();
		
		int[] output = new int[2];
		boolean flag = false;
		
		for (int i = 0; i < nums.length - 1; i++) {
			//nums[i] 값이 결정
			//i에 대한 output의 보수는 유일하며, 그 결과도 유일하다고 가정되었기 때문에
			//i에 해당하는 j 역시 결정된 것이다.
			//따라서 j가 nums의 요소인지만 확인하면 된다.
			//답변2로 구현해보자!
			for (int j = i + 1; j < nums.length; j++) {
				if (nums[i] + nums[j] == target) {
					output[0] = i;
					output[1] = j;
					flag = true;
					break;
				}
			}
			if (flag) {
				break;
			}
		}
		System.out.println("Output: [" + output[0] + "," + output[1] + "]");
		
		long end = System.nanoTime();
		System.out.println("Test: " + (end - start) * 1e-9 + " sec.");
		
		start = System.nanoTime();
		
		output = new int[nums.length];
		int num2 = 0;
		Integer[] nums2 = new Integer[nums.length];
		for (int i = 0; i < nums.length; i++) {
			nums2[i] = nums[i];
		}
		
		for (int i = 0; i < nums.length - 1; i++) {
			//답변2
			int num1 = nums[i];
			num2 = target - num1;
//			System.out.println(num1);
//			System.out.println(num2);
//			System.out.println(Arrays.asList(nums2).contains(num2));
			//int[]을 asList할 경우 primitive 타입을 자동 형변환해주지 않기 때문에 List<int[]> 타입을 리턴한다.
			//원하는 결과값을 얻기 위해서는 Integer[]을 asList 메소드에 넘겨주어야 한다.
			if ((num2 >= -1000000000 && num2 <= 1000000000) && Arrays.asList(nums2).contains(num2)) {
				output[0] = i;
				break;
			}
		}
		for (int i = output[0] + 1; i < nums.length; i++) {
			if (nums[i] == num2) {
				output[1] = i;
				break;
			}
		}
		//num1 값(정확히 말하면 num1 값에 대한 target의 보수인 num2 값)과 인덱스를 별도의 map 변수에 저장하여
		//하나의 for문 안에서 해당 num1에 대한 num2 값이 nums 배열에 있는지 확인할 수 있다.
		//이를 적용하여 답변3을 작성해보자.
		
		System.out.println("Output: [" + output[0] + "," + output[1] + "]");
		
		end = System.nanoTime();
		System.out.println("Test: " + (end - start) * 1e-9 + " sec.");
		
		start = System.nanoTime();
		
		output = new int[nums.length];
		HashMap<Integer, Integer> hmOutput = new HashMap<Integer, Integer>();
		
		for (int i = 0; i < nums.length; i++) {
			//결과(보수 값과 인덱스) map 넣기
			hmOutput.put(target - nums[i], i);
			
			//map에서 현재 num가 존재하는지 찾기
			if (i > 0) {
				if (hmOutput.containsKey(nums[i]) && hmOutput.get(nums[i]) != i) {	//자기 자신(숫자가 아닌 인덱스로)을 보수로 갖는 경우를 제외(두 번 사용하지 않는다고 했기 때문에)
					output[0] = hmOutput.get(nums[i]);
					output[1] = i;
					break;
				}
			}
			//순서를 바꾸면 조건을 줄일 수 있다.
			//먼저 찾고 나중에 넣으면 자기 자신을 제외해야 하는 조건을 주지 않아도 된다.
			
			//현재 인덱스를 기준으로
			//지난 인덱스의 value와 비교하는 것이다.
			//즉, 0번째 인덱스는 비교 대상이 없으니 수행하지 않고, 1번째 인덱스는 0번째 인덱스 값과 비교, 2번째 인덱스는 1,2번째 인덱스 값과 비교해가는 식이다.
			//for문이 전체 수행된다면, 모든 경우의 수에 대해 비교가 가능한 것이다.
		}
		
		System.out.println("Output: [" + output[0] + "," + output[1] + "]");
		end = System.nanoTime();
		System.out.println("Test: " + (end - start) * 1e-9 + " sec.");
		//추가 고려 사항
		//범위 제약 사항에 따라 변수를 int가 아닌 long 타입으로 선언해야할 수도 있다.
	}


20. Valid Parentheses
Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Every close bracket has a corresponding open bracket of the same type.

# java-junior
1544. Make The String Great

1. 인접한 알파벳이 각각 대소문자로 같은 알파벳인지 확인
 - 방법 :
  1. 비교할 알파벳을 toUpperCase() or toLowerCase()를 통해 같은 알파벳인지 판별 >> 같은 알파벳일지라도 대소문자가 변환되어 같은 것인지 변환되지 않고 모두 대문자 혹은 소문자로 같은 것인지 판별(변환 전 값과 변환 후 값 비교가 필요)
  2. 알파벳의 아스키 코드 값으로 알파벳 종류와 대소문자를 판별 + 같은 알파벳의 아스키 코드 값 차이는 32로 동일하므로 인접한 알파벳 아스키 코드 값 차이가 32인지 확인
 - 인접한 알파벳을 비교하는 방법
  1. for문
 
2. 같은 알파벳일 경우 두 알파벳을 문자열에서 제거
 - 방법 :
  1. String.substring한 값을 다시 String에 대입
  2. List에 제거 대상이 아닌 알파벳을 add하여 결과 값을 String으로 만듦(for문 필요)

*시나리오를 나눌 수 있는 방법
Input: s = "abBAcC"
Output: ""
Explanation: We have many possible scenarios, and all lead to the same answer. For example:
"abBAcC" --> "aAcC" --> "cC" --> ""
"abBAcC" --> "abBA" --> "aA" --> ""
 - 인접한 알파벳을 비교하는 방향을 어디에서부터 찾아나가는지에 따라 시나리오가 나뉘는 것으로 보인다. 방법의 차이는 아니라고 생각한다.

테스트 결과
 - 실패 1
  원인 : 문자열 제거 후 남은 앞의 알파벳과 뒤의 알파벳을 비교하는 로직을 고려하지 않았다. 즉, 현재 로직으로는 비교하고자 하는 알파벳이 통과할 경우 문자열 제거 후 새롭게 인접하게 된 알파벳과 새로 비교하는 로직이 누락되어 있다.
   - 방법 :
    1. 알파벳을 비교하는 for문을 완료한 후 알파벳이 제거된 새로운 결과가 나올 경우 다시 비교 for문을 수행한다. >> 문제 : 제거가 계속 수행되는 for문일 경우 반복문 수행을 계속 호출할 필요가 있는 재귀의 시간 복잡도를 갖게 된다.
	2. 문자열 제거가 일어난 시점에 새로 인접하게 될 두 알파벳을 비교한다.
	 2.1. i와 i+1의 알파벳이 제거됐을 경우 해당 시점의 i-1과 i+2를 비교한다. >> 문제 : 인접하게 될 알파벳이 계속해서 제거가 필요한 경우 마찬가지로 재귀의 시간 복잡도를 갖게 된다.
	 2.2. 문자열 제거 후 앞 문자열과 뒤 문자열을 합쳐 리턴한 문자열 s에서 제자리로 돌아와 반복문을 수행하는 것이 아닌 하나 이전의 인덱스에서 다시 비교를 시작한다. >> 반복문 수행 횟수는 경우에 따라 무한으로 늘어날 수 있지만 중첩이 아닌 단일한 반복문을 수행하므로 복잡도를 낮출 수 있을 것이다.
   
class Solution {
	public String makeGood(String s) {
		for (int i = 0; i <= s.length() - 2; i++) {
			char[] ca = s.toCharArray();
			int nAsciiCodeDiffVal = (char)ca[i] - (char)ca[i + 1];
			//수정1
			//굳이 char 배열 변수를 할당할 필요가 있을까?
//			nAsciiCodeDiffVal = s.substring(i, i + 1) - s.substring(i + 1, i + 2);
			//char 배열이 더 효율적으로 보임
			//아스키 코드 값으로 변환하기 위해서는 char형변환이 필요하며, substring의 경우 인덱스 오류 방지를 위해 조건문이 추가로 필요할 것으로 보이기 때문이다.
			if (nAsciiCodeDiffVal == 32 || nAsciiCodeDiffVal == -32) {
				//substring 인덱스 오류 방지
				String sFront = i == 0 ? "" : s.substring(0, i);
				String sBack = i == s.length() - 2 ? "" : s.substring(i + 2);
				//s에 다시 초기화하여도 새로운 s에 대해 새로운 인덱스로 반복문을 수행하기 때문에 새로운 변수에 할당할 필요가 없다.
				s = sFront + sBack;
//				System.out.println("i : " + i + ", s : " + s);
				//자른 문자열에 대해 현재 인덱스에서 다시 한 번 로직 수행
				//수정1
				//새로 인접할 알파벳(자르고 남은 앞 문자열의 마지막 알파벳과 뒷 문자열의 첫 알파벳) 간의 비교를 위해 한 칸 앞의 인덱스에서 다시 비교를 시작한다.
				//문자열 s의 첫 알파벳일 경우에는 앞 문자열이 없으므로 제자리로 돌아간다.
				i = i == 0 ? i - 1 : i - 2;
			}
		}
		
		return s;
	}
}


1. Two Sum
Input : int[] nums, int target
Output : int[] indexes(nums[indexes]의 합이 target이 되는 index 값들)
Constraint
1. return 값은 하나만 존재한다고 가정
2. 동일한 nums[indexes] 값을 두 번 사용할 수 없음
3.
 2 <= nums.length <= 104
 -10^9 <= nums[i] <= 10^9
 -10^9 <= target <= 10^9
 
Solution
1. int[] nums에서 두 요소를 추출하는 모든 경우의 수에서 그 합이 target이 되는 결과를 찾는다.
 >> nums.length의 최대값은 104(N)로 최대 경우의 수를 구하기 위해서는 104*103(N*(N-1))의 중첩 반복문을 수행해야 한다.
 이는 O(N^2)의 시간 복잡도를 갖게 되므로, 복잡도가 큰 방식이라 할 수 있다.

2. 어떠한 두 수를 더해 target 값이 되는 경우의 수에서 해당 두 수가 int[] nums의 요소인지 확인한다.
 >> -10^9 <= nums[i] <= 10^9, -10^9 <= target <= 10^9의 범위 조건에 따르면
 target의 최소값 -10^9는 nums[i] 범위에 따라 최소 -10^9와 최대 0의 범위 내 수의 합, -10^9+1은 최소 -10^9와 최대 1의 범위 내 수의 합, ..., 0은 최소 -10^9와 최대 10^9의 범위 내 수의 합, ..., 최대값 10^9는 최소 0과 최대 10^9의 범위 내 수의 합으로 만들어진다.
 따라서 target이 0이 될 때 두 수의 경우의 수는 최대가 된다.
 이처럼 두 수의 합의 경우의 수를 모두 계산하는 것 또한 1의 방법과 마찬가지로 높은 복잡도를 보일 것으로 보이며, 최소, 최대값에 따라 변하는 경우의 수를 모두 고려하는 것 또한 쉽지 않다고 생각한다.
 >> 다른 관점
 어떠한 두 수를 더해 target 값이 된다는 것은 target의 보수 개념에 해당한다.
 즉, 한 수가 정해질 경우 이 수에 대한 target의 보수는 자동으로 도출된다.
 따라서 int[] nums에서 i = 0부터 i++ 반복문에서 nums[i] 값에 대응하는 target의 보수 값을 찾고, 이 값이 int[] nums의 요소인지 확인하면 된다.
 >>> Condition
 if(nums.contain(target - nums[i])) //int[] 배열의 경우 요소가 존재하는지 확인하기 위해서는 직접 반복문에서 찾거나, String[] 혹은 List로 변환하여 찾아야 한다.
 -- 수정
 문제의 return 값은 indexes이므로, nums[indexes]와 indexes 값이 함께 저장되어야 한다. 따라서 Map을 활용하는 것이 좋다.
 Condition == true >> i와 Map에서 target - nums[i] 값을 target의 보수로 찾는 index(이전 요소에서 Map에 보수를 기록한 index)를 함께 return 한다.
 Condition == false >> i++ 하면서 다시 조건을 탐색한다. + i++ 하기 전에 보수 value와 i를 Map에 담는다.


20. Valid Parentheses
Input : String s
Output : boolean isValid
 Valid if
 1. 여는 괄호는 동일한 종류의 괄호로 닫아야 한다.
 2. 여는 괄호는 올바른 순서대로 닫아야 한다.
 3. 모든 닫는 괄호는 동일한 종류로 대응되는 여는 괄호가 있다.
 
Solution
먼저 s를 괄호 문자 하나씩 잘라 배열 형태로 만들어 반복문을 수행할 수 있게 한다.
0. s가 여는 괄호로 시작하는 지 확인한다.
1. 여는 괄호일 경우 그에 대응하는 닫는 괄호를 Stack에 넣는다.
2. 닫는 괄호일 경우 괄호가 순서에 맞게 닫고 있는지 확인하기 위해 Stack에서 peek() 메서드로 추출한 괄호와 비교한다.
비교하여 일치할 경우에는 순서와 종류에 맞는 닫는 괄호이므로 다음 반복문으로 넘어간다(Condition == true).
3. 규칙에 맞지 않는 괄호가 있을 경우 isValid = false 값을 반환하고 반복문을 종료한다(Condition == false).
4. return false 없이 반복문이 모두 수행됐다면, Stack이 모두 비워졌는지 확인하여 비워졌다면 return true, 아니면 return false 값을 반환한다.
 >>> Condition 1
 + 반복문에서 항상 조건을 탐색하지는 않는다. 여는 괄호일 경우와 닫는 괄호일 경우를 나눈다. 아래 조건은 닫는 괄호일 때만 수행하도록 조건문 내의 조건문으로 확인한다.
 if(bracket[i] == Stack.peek())
 Condition == true >> 다음 반복문 수행
 Condition == false >> isValid = false 값을 return
 >>> Condition 2
 if(Stack.isEmpty())
 Condition == true >> isValid = true
 Condition == false >> isValid = false


35. Search Insert Position
Input : int[] nums, int target
Output : int index(int[] nums에 요소로 target이 있을 경우 index, 없을 경우 target이 들어갈 때 위치할 index)

Solution >> Up-Down
1. int[] nums의 가운데 위치한 요소를 선택한다.
2. 선택한 요소와 target 값을 비교하여 같을 경우에는 해당 요소의 index를 반환한다.
3. 같지 않을 경우, target이 선택한 요소보다 작으면 처음부터 선택한 요소 - 1번째 요소까지로, 크면 선택한 요소 + 1번째부터 마지막 요소까지로 범위를 조정하여 1의 순서로 돌아가 반복문을 수행한다.
4. target과 같은 값의 요소가 없을 경우 범위 조정 과정에서 선택한 요소에 -1 혹은 + 1한 값이 범위 시작의 index 값보다 작아지거나 커진다(다시 말해, 범위 시작 index가 끝 index보다 작아질 수 있다).
즉, int[] nums에서 같은 값을 갖는 요소를 찾지 못해 범위 index의 역전이 발생하게 되는 것이다. 따라서 무한 반복의 종료를 해당 조건으로 판단한다.
 >>> Condition
 + start <= end이면 계속 반복
 if(nums[mid] == target) >> return mid
 else if(nums[mid] < target) >> start ~ mid-1 범위에서 다시 탐색
 else >> mid+1 ~ end 범위에서 다시 탐색
트리
 - 노드 : 동그라미. 보통 데이터가 담기는 곳
 - 엣지 : 노드와 노드 사이를 이어주는 선. 노드간의 관계
 - 경로 : 엣지로 연결된, 즉 인접한 노드들로 이뤄진 시퀀스. 경로의 길이는 경로에 속한 엣지의 수
 - 트리의 높이 : 루트 노드에서 말단 노드에 이르는 가장 긴 경로의 엣지 수.
 - 트리의 깊이 : 루트 노드에서 특정 노드까지 경로의 엣지 수. 특정 깊이를 가지는 노드의 집합을 레벨이라고 부른다.
 - 트리의 속성 중 가장 중요한 것은 '루트 노드를 제외한 모든 노드는 단 하나의 부모 노드를 가진다'는 것이다. 이 속성 때문에 트리는 다음 성질을 만족한다.
	- 임의의 노드에서 다른 노드로 가는 경로는 유일하다.
	- 회로(cycle)가 존재하지 않는다.
	- 모든 노드는 서로 연결되어 있다.
	- 엣지를 하나 자르면 트리가 두 개로 분리된다.
	- 엣지의 수는 노드의 수에서 1을 뺀 것과 같다
이진 트리 : 자식 노드가 최대 두 개인 노드들로 구성된 트리. 정이진트리(full binary tree), 완전이진트리(complete binary tree), 균형이진트리(balanced binary tree) 등이 있다.
 - 정이진트리 : 모든 레벨에서 노드들이 꽉 채워진(=잎새 노드를 제외한 모든 노드가 자식 노드 2개를 가짐) 이진트리
 - 완전이진트리 : 마지막 레벨을 제외한 모든 레벨에서 노드들이 꽉 채워진 이진트리
	- 정이진트리와 완전이진트리는 1차원 배열로도 표현이 가능하다.
 - 균형이진트리 : 모든 잎새 노드의 깊이 차이가 많아야 1인 트리. 예측 가능한 깊이를 가지며, 노드가 n개인 균형이진트리의 깊이는 log n을 내림한 값. => 모든 잎새 노드라는 표현은 적절하지 않을 것으로 보인다. 정확한 표현은 두 서브 트리의 깊이 차이가 1 이하인 트리 구조를 균형 이진트리라고 하며, 이를 균형이 잡힌 상태라고 부른다.
 다시 말해 깊이 차이가 2 이상인 경우에는 균형이 깨졌다고 하며, 이러한 구조의 트리는 회전을 통해 균형을 맞추는 작업을 거칠 수 있다.
 아마 균형이진트리에서 N개의 노드에 대한 시간 복잡도가 O(log N)이 나오는 것으로 보인다. 깊이 h에 대한 시간 복잡도 O(h)를 갖지만 일반적으로 데이터 수에 대한 복잡도를 나타내므로 h를 N 값으로 치환하면
 N <= 2^h-1 => h = log N+1 => O(h) = O(log N)
 
위 포화 이진트리(정 이진트리) 같은 경우에는 루트 노드를 1번으로 하고 레벨별로 왼편에서 오른 편오로 차례로 노드 위치에 번호를 2^(h+1)-1까지 부여가 가능하다.
그런데 만일 높이가 h이고 노드 수가 n, 일때 n<=(2^(h+1)-1)인 이진트리를 노드의 레벨 순수에 따라 노드 번호를 붙인다면 이때 각 노드 번호의 위치가 포화 이진트리 번호 1에서 n까지의 위치와 모두 정확하게 일치한다면 이 트리를 완전 이진트리라고 한다.
즉 루트 노드를 1이라고 하고 그외에 모든 노드가 왼쪽에서부터 오른쪽까지 꽉 차서 노드의 수가  n<=()라면 완전 이진트리이다. 아래 그림은 완전 이진트리의 예이다.


70. Climbing Stairs
Input : int n(계단 수)
Output : int numberOfCases
Constraint
1. 계단은 1계단 혹은 2계단 오를 수 있다.

Solution
1. 1과 2를 조합하여 숫자 n을 만드는 경우의 수 : n = 1*a + 2*b(a <= n까지 n번의 반복문)
반복문 내에서 1과 2를 나열하는 경우의 수를 연산하여 총 경우의 수를 누적한다.
2. 
n = 1일 때 계단을 오르는 경우의 수 -> n = 2일 때 계단을 오르는 경우의 수는 1계단에서 1 step 하는 경우와 0계단에서 2 step 하는 경우의 합으로 구해진다
-> n = 3일 때의 경우의 수는 마찬가지로 1계단에서 2 step 하는 경우와 2계단에서 1 step 하는 경우의 수로 구해진다 -> 이렇게 n은 마지막 계단을 1 step 오르는 경우와 2 step 오르는 경우의 합으로 구해지며 이는 n-1과 n-2 계단의 경우의 수 합으로 구할 수 있다.
>>
우선 인덱스 대신 계단 개수로 표기하면
[0]
[1] = 1
[2] = [1] + 1
[3] = [2] + [1]
...
[n] = [n-1] + [n-2] => 즉 1부터 n-1까지의 경우의 수 값이 저장되어 있어야 하며, 1부터 n까지 경우의 수 계산을 수행한다.
 >> Condition
 반복 : n까지
 종료 조건 : 없음
 수행 : [n] = [n-1] + [n-2]


94. Binary Tree Inorder Traversal
Input : TreeNode root
Output :

Solution
*
Preorder Traversal
InOrder Traversal
Postorder Traversal


101. Symmetric Tree
Input : TreeNode root
Output : boolean isSymmetric

Solution
1. 주어진 배열을 트리 깊이에 따라 가상으로 자른다(나눈다, 그룹핑한다).
같은 그룹 내에서 대칭인지 확인한다.
 예상 시간 복잡도 : 깊이 * 동일 깊이 내 모든 노드(혹은 모든 노드의 1/2)에 연산 필요 = h * 2^(h-1) = logN * 2^(logN - 1)
 
2. 순회(탐색)으로 도출한 값들을 Queue에 넣는다.
역순회(탐색)를 수행하면서 Queue에서 값들을 하나씩 비교하여 서로 일치하는 지 확인한다(대칭이라면 역순회로 도출해도 순회에서 먼저 들어간 값이 먼저 나와야 하므로 FIFO)
단, 순회 시 root까지만 수행한다.
 예상 시간 복잡도 : 균등 노드일 때 깊이 h에 대하여 1/2logN의 연산은 수행할 것으로 보이므로 O(logN)의 시간 복잡도를 보인다.
 도출한 값을 저장할 Queue에 대한 추가 공간이 필요하다.
 >> Condition 1
 수행 : 순회(조건 없음)
 >> Condition 2
 수행 : 역순회
 종료 조건 : 역순회에서 탐색한 값이 Queue.poll()한 값과 일치할 경우 다음 순회 진행, 일치하지 않을 경우 isSymmetric = false return


104. Maximum Depth of Binary Tree
Input : TreeNode root
Output : int maxDepth

Solution
* Tree 구조에 대한 이해
Tree 객체는 멤버변수로 Tree 객체를 갖는 구조이다.
즉 특정 Node에 로직을 적용할 경우, 그 Node의 멤버변수인 하위 노드를 참조하여 동일하게 적용할 수 있다.
root Node인 Top부터 하위로 이어지는 Down 방식인 재귀식 구현 방식을 생각해볼 수 있다.
1. maxDepth를 return 하는 메서드에 root 인자를 던질 경우 root Node의 left, right 노드인 TreeNode 객체를 다시 인자로 던지는 maxDepth 메서드를 호출하는 재귀식을 구현한다.
2. maxDepth를 return 해야 하므로 left route와 right route 중 더 큰 값을 return 하는 Math.max() 메서드를 활용한다.
 >> Condition 1
 수행 : 순회
 조건 : 인자로 받은 TreeNode 객체가 null이 아닐 경우(최하위 노드까지 수행)
 Condition == true >> 자기 자신을 depth = 1로 계산하고, 하위 노드의 maxDepth로 얻은 값을 더하여 return 한다.
 Condition == false >> 더 이상 Node가 없으므로 0을 return 한다.


108. Convert Sorted Array to Binary Search Tree
Input : int[] nums
Output : TreeNode tnBST

Solution
1. 균형 이진 트리를 만들기 위해 배열의 mid index를 value로 초기화하고 index를 기준으로 왼쪽 요소는 left TreeNode로, 오른쪽 요소는 right TreeNode로 배치하면 된다.
그래야만 가장 하위 노드가 1개만 남더라도 높이 차이가 1인 균형 이진 트리로 구성된다.
따라서 index를 기준으로 value, left, right를 초기화하고 left, right의 경우 재귀 함수로 수행하도록 한다.
 >> Condition
 if(nums.length > 0)
 Condition == true >> value, left, right 초기화
 Condition == false >> return ?? >> Solution에서 요구하는 sortedArrayToBST 메서드는 TreeNode 객체를 반환한다. 재귀 함수의 결과 역시 TreeNode 객체를 반환해야 최종 TreeNode 객체가 완성될 것이며, 따라서 재귀 함수에는 추가적으로 TreeNode 객체를 인자로 넘겨주어야 한다.
 이는 노드에 대한 하위 노드를 재귀적으로 초기화해줘야 Tree 구조를 완성할 수 있기 때문이기도 하다.
 -- 수정
 메서드 인자로 넘길 배열의 index 정보만 넘겨줘도 해당 메서드 내에서 생성하여 return한 TreeNode 객체로 left, right를 초기화하는 것이기 때문에 넘겨줄 필요가 없다.


118. Pascal's Triangle
Input : int numRows
Output : List<List<Integer>> pascalTriangle

Solution
1. 가장 위 꼭지점부터 numRows 개수만큼 삼각형을 크기를 키운다고 생각한다.
n행 m열의 값음 n-1행 m열의 값과 n-1행 m+1열의 값이 더해져 초기화된다.
 >> Condition
 for (i = 1; i <= numRows; i++) 반복문 수행
 수행 : 1부터 numRows까지의 각 행은 행 숫자만큼 열의 크기를 갖는다. 따라서 j는 1부터 numRows까지의 내부 반복문이 필요하다. -- 수정 : numRows까지일 경우 모든 층의 열을 동일하게 수행하므로 삼각형 모양이 아닌 사각형 모양이다. j 값은 i 값에 따라 변동되어야 한다.
 내부 반복문에서는 실제 n행 m열에 들어갈 값을 i, j 값으로부터 도출한다.
 그러기 위해서는 i와 j가 시작하는 행과 열에 대한 초기화가 필요하며, 이 값은 1이다.


121. Best Time to Buy and Sell Stock
Input : int[] prices >> Output : int maxProfit
Flow
1. prices 배열에서 ith day에 해당하는 가격에 주식 한 주를 구입한다.
2. i보다 큰 yth day의 주식 가격에 팔았을 때 차액이 가장 큰 경우를 구한다.
 2.1. 차액이 모두 마이너스일 경우 주식 거래가 일어나지 않는다고 결론 짓고 0을 반환한다.

Solution
Flow 1 : day i 선택
Flow 2 : day i 선택에 따른 day y 선택
1. 0부터 차례대로 넘어가며 전 값보다 작아지는 i 선택. 이후에는 플러스 차액을 기록. 계속 진행하며 i보다 작은 값이 나온다면? 1. 최대 차액이 그 전에 나온다. 2. 최대 차액이 그 후에 나온다. 그냥 최소 값 변수와 차액 변수만 가지고 있으면 비교 조건으로 최대 차액을 구할 수 있다고 생각.


★★
136. Single Number
Input : int[] nums >> Output : int singleElementNumber
★★
Constraints
use only constant extra space : 의미를 잘 모르겠다.
Flow
1. nums element가 처음 나왔는가? true >> 일단 저장, false >> 저장되어 있는 element 제거 후 통과
2. 저장한 공간에 남은 숫자를 반환한다.

Solution
1.
Flow 1 : i = 0부터 Map에 i 값을 key로 하는 element를 찾는다. 없으면 add() 하고, 있으면 remove() 한다.
Flow 2 : Map에서 keySet()으로 남은 key 값을 찾아 해당 key 값을 반환한다.
2.
Flow 1-1 : i = 0부터 Map에서 i 값을 key로 하는 value에 count를 1씩 증가시키는 반복문을 수행한다(nums 요소 전체 수행하여 다음 번 탐색을 위한 준비)
Flow 1-2 : i = 0부터 i 값을 key로 Map의 value를 찾아 value가 1인 key 값을 찾아 반환한다.
★★
XOR 비트 논리 연산자 활용
정수를 비트(2진수로) 표현하면 2^0 2^1 2^2 ... 2^n 형태가 된다.
^ 연산자(XOR 연산자)는 승에 해당하는 0 1 2 ... n의 비트끼리 연산하여 값이 같으면 0, 다르면 1을 반환한다.
nums 요소는 조건에 따라 쌍을 이루는 수를 제외한 나머지 한 개의 수가 남게 되는데,
이는 ^ 연산자로 표현할 경우 각 승에 해당하는 비트에서 쌍을 이루는 값을 제외한 나머지 하나의 값으로 구할 수 있게 된다.
예를 틀어 2^0 비트에 해당하는 곳에 3개의 수가 각각 0, 0, 1의 값일 경우 0 ^ 0 = 0, 0 ^ 1 = 1이 되어 쌍이 아닌 수 1이 결과 값과 일치하는 것을 볼 수 있다.
만약 비트 한 자리에 모두 수가 같은 경우에는 ^ 연산자에 따라 0 ^ 0 ^ 0 = 0, 1 ^ 1 ^ 1 = 1(1 ^ 1 = 0, 0 ^ 1 = 1)이므로 해당 자리에 대해서도 같은 결과 값을 얻을 수 있다.
이로 보아 ^ 연산자는 쌍으로 존재하는 수 가운데 유일하게 한 개의 수가 있을 경우 해당 수를 도출하는 데 사용할 수 있는 연산자의 개념이 된다.


141. Linked List Cycle
Input : ListNode head, (int pos - 제시되지만 메서드 호출 시 파라미터로 넘기지 않음) >> Output : boolean hasCycle
Flow
1. pos 값이 0 ~ head.size() - 2 사이의 값인가? hasCycle = true, 아니면 false
-- 수정 pos 값은 파라미터로 넘기지 않는다. 즉, pos 값과 관계없이 조건으로 true or false를 결정할 수 있는 포괄적 규칙을 생성해야 한다.
>> ListNode 클래스는 다음 노드인 ListNode next 클래스를 변수로 가지고 있다.
무한으로 next에 접근하여도 null이 아닐 경우 cycle을 가지고 있다고 할 수 있다. 만약 cycle 없이 무한으로 연결되어 있는 ListNode라면?? ListNode 클래스를 element로 갖는 List에 head부터 지나온 노드를 담고 next를 수행하면서 List에 있는 노드와 비교하여 같은 경우 cycle을 판단한다.
★★
지나온 노드에 Flag를 표시한다.
ListNode에는 boolean형 변수가 없기 때문에 true/false 개념의 flag 형태를 표시할 수는 없다. 따라서 제시된 문제의 제약 조건을 활용한다.
문제에서 제시된 조건은 -10^5 <= Node.val <= 10^5의 범위이므로 지나온 Node.val에 범위 밖의 숫자를 초기화한 뒤 next Node의 val 값이 범위 밖의 숫자에 해당하는지 확인하면 된다.
범위 밖의 숫자라면 내가 지나오면서 강제로 넣어준 값이므로 다시 돌아왔다는 의미기 때문에 순환한다고 할 수 있다.


160. Intersection of Two Linked Lists
Input : ListNode listA, ListNode listB, (int intersectVal - input으로 주어지지 않는다.) >> Output : ListNode intersectListNode
Flow
1. listA 노드와 listB 노드 간의 직접 비교 : listA 노드 수를 a, listB 노드 수를 b라고 하면 매칭 여부를 계산하기 위해서는 a*b번의 수행이 필요하다.
2. listA 노드 전체를 int val와 ListNode next를 key와 value로 하는 Map에 담는다. 모두 담은 후에 listB 노드 중 Map에서 매칭되는 노드가 있는지 확인 후 가장 먼저 매칭되는 Node를 반환한다.
★★
공통의 노드로 합쳐질 경우 공통 노드의 길이는 같다는 점을 이용한다.
listA와 listB의 길이는 같다는 보장이 없기 때문에 A, B 각각의 전체 노드에서 공통 노드가 시작되는 지점은 다를 수 있다.
하지만 listA에 listB를 결합한 것과 listB에 listA를 결합한 것의 전체 노드 길이는 동일하다. 결합한 두 노드는 끝 부분이 listA와 listB와 같으므로 결합한 노드를 비교하는 것과 A, B 노드를 비교하는 것이 같은 셈이다.
결합한 노드의 길이는 같기 때문에 전체 노드에서 공통 노드가 시작되는 지점은 같아지게 된다.
따라서 이 intersectVal을 찾으면 된다.


169. Majority Element

Given an array nums of size n, return the majority element.

The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.

 

Example 1:

Input: nums = [3,2,3]
Output: 3
Example 2:

Input: nums = [2,2,1,1,1,2,2]
Output: 2
 

Constraints:

n == nums.length
1 <= n <= 5 * 104
-109 <= nums[i] <= 109


package com.lg;

import java.io.IOException;
import java.util.Stack;

public class Kyjtest4
{
	
	public static void main(String[] args) throws IOException
	{
//		Stack<String> stack = new Stack<String>();
//		stack.push("a");
//		stack.push("b");
//		stack.push("c");
//		stack.pop();
//		String peekVal = stack.peek();
//		System.out.println(peekVal);
//		
//		System.out.println(stack);
//		System.out.println(stack.toString());
//		
//		stack.clear();
//		System.out.println(stack);
		Solution sol = new Solution();
		System.out.println(sol.isValid("()"));
		System.out.println(sol.isValid("()[]{}"));
		System.out.println(sol.isValid("({[]})"));
		System.out.println(sol.isValid("(()())"));
		System.out.println(sol.isValid("(]"));
	}
}

class Solution
{
	public boolean isValid(String s) {
		
		if (s.length() % 2 != 0) {
			return false;
		}
		
		Stack<Character> st = new Stack<Character>();
		for (int i = 0; i < s.length(); i++) {
			char c = s.charAt(i);
			switch (c) {
				case '(':
					st.push(')');
					break;
				case '{':
					st.push('}');
					break;
				case '[':
					st.push(']');
					break;
				default:
					if (i == 0 || st.empty()) {
						return false;
					}
					
					char cp = st.peek();
					if (c == cp) {
						st.pop();
					} else {
						return false;
					}
					break;
			}
			
			if (i == s.length() - 1 && !st.empty()) {
				return false;
			}
		}
		
		return true;
	}
}


package com.lg;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;

public class Kyjtest6
{
	
	public static void main(String[] args) throws IOException
	{
		int[] nums = {2, 7, 11, 15};
		int target = 9;
		
		long start = System.nanoTime();
		
		int[] output = new int[2];
		boolean flag = false;
		
		for (int i = 0; i < nums.length - 1; i++) {
			//nums[i] 값이 결정
			//i에 대한 output의 보수는 유일하며, 그 결과도 유일하다고 가정되었기 때문에
			//i에 해당하는 j 역시 결정된 것이다.
			//따라서 j가 nums의 요소인지만 확인하면 된다.
			//답변2로 구현해보자!
			for (int j = i + 1; j < nums.length; j++) {
				if (nums[i] + nums[j] == target) {
					output[0] = i;
					output[1] = j;
					flag = true;
					break;
				}
			}
			if (flag) {
				break;
			}
		}
		System.out.println("Output: [" + output[0] + "," + output[1] + "]");
		
		long end = System.nanoTime();
		System.out.println("Test: " + (end - start) * 1e-9 + " sec.");
		
		start = System.nanoTime();
		
		output = new int[nums.length];
		int num2 = 0;
		Integer[] nums2 = new Integer[nums.length];
		for (int i = 0; i < nums.length; i++) {
			nums2[i] = nums[i];
		}
		
		for (int i = 0; i < nums.length - 1; i++) {
			//답변2
			int num1 = nums[i];
			num2 = target - num1;
//			System.out.println(num1);
//			System.out.println(num2);
//			System.out.println(Arrays.asList(nums2).contains(num2));
			//int[]을 asList할 경우 primitive 타입을 자동 형변환해주지 않기 때문에 List<int[]> 타입을 리턴한다.
			//원하는 결과값을 얻기 위해서는 Integer[]을 asList 메소드에 넘겨주어야 한다.
			if ((num2 >= -1000000000 && num2 <= 1000000000) && Arrays.asList(nums2).contains(num2)) {
				output[0] = i;
				break;
			}
		}
		for (int i = output[0] + 1; i < nums.length; i++) {
			if (nums[i] == num2) {
				output[1] = i;
				break;
			}
		}
		//num1 값(정확히 말하면 num1 값에 대한 target의 보수인 num2 값)과 인덱스를 별도의 map 변수에 저장하여
		//하나의 for문 안에서 해당 num1에 대한 num2 값이 nums 배열에 있는지 확인할 수 있다.
		//이를 적용하여 답변3을 작성해보자.
		
		System.out.println("Output: [" + output[0] + "," + output[1] + "]");
		
		end = System.nanoTime();
		System.out.println("Test: " + (end - start) * 1e-9 + " sec.");
		
		start = System.nanoTime();
		
		output = new int[nums.length];
		HashMap<Integer, Integer> hmOutput = new HashMap<Integer, Integer>();
		
		for (int i = 0; i < nums.length; i++) {
			//결과(보수 값과 인덱스) map 넣기
			hmOutput.put(target - nums[i], i);
			
			//map에서 현재 num가 존재하는지 찾기
			if (i > 0) {
				if (hmOutput.containsKey(nums[i]) && hmOutput.get(nums[i]) != i) {	//자기 자신(숫자가 아닌 인덱스로)을 보수로 갖는 경우를 제외(두 번 사용하지 않는다고 했기 때문에)
					output[0] = hmOutput.get(nums[i]);
					output[1] = i;
					break;
				}
			}
			//순서를 바꾸면 조건을 줄일 수 있다.
			//먼저 찾고 나중에 넣으면 자기 자신을 제외해야 하는 조건을 주지 않아도 된다.
			
			//현재 인덱스를 기준으로
			//지난 인덱스의 value와 비교하는 것이다.
			//즉, 0번째 인덱스는 비교 대상이 없으니 수행하지 않고, 1번째 인덱스는 0번째 인덱스 값과 비교, 2번째 인덱스는 1,2번째 인덱스 값과 비교해가는 식이다.
			//for문이 전체 수행된다면, 모든 경우의 수에 대해 비교가 가능한 것이다.
		}
		
		System.out.println("Output: [" + output[0] + "," + output[1] + "]");
		end = System.nanoTime();
		System.out.println("Test: " + (end - start) * 1e-9 + " sec.");
		//추가 고려 사항
		//범위 제약 사항에 따라 변수를 int가 아닌 long 타입으로 선언해야할 수도 있다.
	}
}


package com.lg;

import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class Kyjtest7
{
	public Node root;
	
	private boolean find(int value) {
		Node currentNode = root;
		while (currentNode != null) {
			if (value == currentNode.getValue()) {
				return true;
			} else if (value < currentNode.getValue()) {
				currentNode = currentNode.getLeft();
			} else {
				currentNode = currentNode.getRight();
			}
		}
		
		return false;
	}
	
	private boolean insert(int value) {
		Node newNode = new Node(value);
		if (find(value)) {
			return false;
		}
		if (root == null) {
			root = newNode;
			return true;
		}
		
		Node currentNode = root;
		Node parentNode;
		while (true) {
			parentNode = currentNode;
			if (value < currentNode.getValue()) {
				currentNode = currentNode.getLeft();
				if (currentNode == null) {	//더 이상 왼쪽노드가 없을 경우
					parentNode.setLeft(newNode);
					return true;
				}
			} else {
				currentNode = currentNode.getRight();
				if (currentNode == null) {
					parentNode.setRight(newNode);
					return true;
				}
			}
		}
	}
	
	//전위 탐색(Preorder Traversal) : root -> left -> right
	//전위 탐색은 깊이 우선 탐색(DFS)
	private List<Integer> preOrderTraverse(Node focusNode, List<Integer> integers) {
		if (focusNode != null) {
			integers.add(focusNode.getValue());
			preOrderTraverse(focusNode.getLeft(), integers);
			preOrderTraverse(focusNode.getRight(), integers);
		}
		
		return integers;
	}
	
	//중위 탐색(Inorder Traversal) : left -> root -> right
	//중위 탐색은 오름차순 정렬
	private List<Integer> inOrderTraverse(Node focusNode, List<Integer> integers) {
		if (focusNode != null) {
			inOrderTraverse(focusNode.getLeft(), integers);
			integers.add(focusNode.getValue());
			inOrderTraverse(focusNode.getRight(), integers);
		}
		
		return integers;
	}
	
	//후위 탐색(Postorder Traversal) : left -> right -> root
	private List<Integer> postOrderTraverse(Node focusNode, List<Integer> integers) {
		if (focusNode != null) {
			postOrderTraverse(focusNode.getLeft(), integers);
			postOrderTraverse(focusNode.getRight(), integers);
			integers.add(focusNode.getValue());
		}
		
		return integers;
	}
	
	//너비 우선 탐색(BFS)
	//층별 탐색 - Queue 이용
	private List<Integer> BFS(Node focusNode) {
		if (focusNode == null) {
			return null;
		}
		
		List<Integer> result = new ArrayList<Integer>();
		Queue<Node> queue = new LinkedList<Node>();
		queue.add(focusNode);
		
		while (!queue.isEmpty()) {
			int size = queue.size();
			for (int i = 0; i < size; i++) {
				Node poll = queue.poll();
				
				if (poll.getLeft() != null) {
					queue.add(poll.getLeft());
				}
				if (poll.getRight() != null) {
					queue.add(poll.getRight());
				}
				
				result.add(poll.getValue());
			}
		}
		
		return result;
	}
	
	public static void main(String[] args) throws IOException
	{
		
	}
}

class Solution {
	public int searchInsert(int[] nums, int target) {
		int startIdx = 0;
		int endIdx = nums.length - 1;
		
		while (startIdx <= endIdx) {
			int searchIdx = (startIdx + endIdx) / 2;
			int searchValue = nums[searchIdx];
			
			if (target == searchValue) {
				return searchIdx;
			} else if (target < searchValue) {
				endIdx = searchIdx - 1;
			} else {
				startIdx = searchIdx + 1;
			}
		}
		
		return startIdx;
	}
}

class Node {
	Node left;
	Node right;
	int value;
	
	public Node(int value) {
		this.value = value;
		this.left = null;
		this.right = null;
	}
	
	public Node getLeft() {
		return left;
	}
	
	public void setLeft(Node left) {
		this.left = left;
	}
	
	public Node getRight() {
		return right;
	}
	
	public void setRight(Node right) {
		this.right = right;
	}
	
	public int getValue() {
		return value;
	}
	
	public void setValue(int value) {
		this.value = value;
	}
}


package com.lg;

import java.io.IOException;

public class Kyjtest8
{
	
	public static void main(String[] args) throws IOException
	{
		//시간복잡도
		/*
		 * 알고리즘에 의해서 수행되는 연산의 개수를 세어 예측할 수 있다.
		 * 그러므로 걸리는 시간의 총량과 알고리즘에 의해 수행되는 기본 연산의 개수는 최대 상수 인자만큼 다르다.
		 */
		int sum1 = 0;
		for (int i = 0; i < N; i++) {
			sum1 += i;
		}
		//연산 수행 수
		/*
		 * sum = 0; 1번
		 * i = 0; 1번
		 * sum += i; N번
		 * i++ N번
		 * 총 = 2N + 2번
		 * Big-O 표기법에서는 최대 차항만 계수없이 표기하면 되기 때문에 O(N)
		 */
		
		int sum2 = (N + 1) * N / 2;
		//연산 수행 수
		/*
		 * N + 1 1번
		 * * N 1번
		 * 2 1번
		 * sum2 대입 1번
		 * 총 = 4번
		 * Big-0 표기법으로 O(1)
		 */
		
		int sum3 = 0;
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < i; j++) {
				sum3 += j;
			}
		}
		//연산 수행 수
		/*
		 * 바깥쪽 반복문은 N번, 안쪽 반복문은 i 값에 따라 반복
		 * i는 0부터 N-1까지 변하고, 안쪽 반복문은 해당 i만큼 반복하므로 0+1+2+...+N-1 = N*(N-1)/2번(등차수열의 합) 반복한다.
		 * 따라서 O(N^2)
		 */
		
		int sum4 = 0;
		for (int i = N; i > 0; i /= 2) {
			for (int j = 0; j < i; j++) {
				sum4 += j;
			}
		}
		//연산 수행 수
		/*
		 * 바깥쪽 반복문은 lgN번(i /= 2이기 때문), 안쪽 반복문은 i 값에 따라 반복
		 * i는 N부터 1까지 변하고, 안쪽 반복문은 해당 i만큼 반복하므로 N+N/2+N/4+...+1 = 2N번(등비수열의 합) 반복한다.
		 * 따라서 O(N) -- 왜 반복의 총 합이 2N이어서 복잡도가 O(N)이 되는거지??
		 * -- 위처럼 계산한 사람이 잘못 계산한 듯하다.
		 */
	}
}


package com.lg.zz;

/**
 * Definition for singly-linked list.
 * @author A76314
 *
 */
public class ListNode
{
	int val;
	ListNode next;
	
	ListNode(int x) {
		val = x;
		next = null;
	}
}


package com.lg.zz;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

public class SolutionTest
{
	
	public static void main(String[] args)
	{
		Solution s = new Solution();
		long startTime;
		long endTime;
		//121. Best Time to Buy and Sell Stock
//		int[] prices1 = {7,1,5,3,6,4};
//		System.out.println(s.maxProfit(prices1));
//		int[] prices2 = {7,6,4,3,1};
//		System.out.println(s.maxProfit(prices2));
		
		//136. Single Number
//		int[] nums1 = {2,2,1};
//		//1
//		startTime = System.nanoTime();
//		System.out.println(s.singleNumber1(nums1));
//		endTime = System.nanoTime();
//		System.out.println((endTime - startTime) * 1e-9 + " sec.");
//		//2
//		startTime = System.nanoTime();
//		System.out.println(s.singleNumber2(nums1));
//		endTime = System.nanoTime();
//		System.out.println((endTime - startTime) * 1e-9 + " sec.");
//		//3
//		startTime = System.nanoTime();
//		System.out.println(s.singleNumber3(nums1));
//		endTime = System.nanoTime();
//		System.out.println((endTime - startTime) * 1e-9 + " sec.");
//		//4
//		startTime = System.nanoTime();
//		System.out.println(s.singleNumber4(nums1));
//		endTime = System.nanoTime();
//		System.out.println((endTime - startTime) * 1e-9 + " sec.");
		/*
			1
			0.0013297 sec.
			0 byte
			1
			1.121E-4 sec. = 0.0001121 sec.
			0 byte
			1
			8.690000000000001E-5 sec. = 0.0000869 sec.
			0 byte
			1
			6.400000000000001E-5 sec. = 0.000064 sec.
			0 byte
		 */
//		int[] nums2 = {4,1,2,1,2};
//		//1
//		startTime = System.nanoTime();
//		System.out.println(s.singleNumber1(nums2));
//		endTime = System.nanoTime();
//		System.out.println((endTime - startTime) * 1e-9 + " sec.");
//		//2
//		startTime = System.nanoTime();
//		System.out.println(s.singleNumber2(nums2));
//		endTime = System.nanoTime();
//		System.out.println((endTime - startTime) * 1e-9 + " sec.");
//		//3
//		startTime = System.nanoTime();
//		System.out.println(s.singleNumber3(nums2));
//		endTime = System.nanoTime();
//		System.out.println((endTime - startTime) * 1e-9 + " sec.");
//		//4
//		startTime = System.nanoTime();
//		System.out.println(s.singleNumber4(nums2));
//		endTime = System.nanoTime();
//		System.out.println((endTime - startTime) * 1e-9 + " sec.");
		
		//141. Linked List Cycle
//		ListNode head1 = new ListNode(3);
//		head1.next = new ListNode(2);
//		head1.next.next = new ListNode(0);
//		head1.next.next.next = new ListNode(-4);
//		head1.next.next.next.next = head1.next;
//		System.out.println(s.hasCycle1(head1));
//		ListNode head2 = new ListNode(1);
//		head2.next = new ListNode(2);
//		System.out.println(s.hasCycle1(head2));
//		System.out.println(s.hasCycle2(head1));
//		System.out.println(s.hasCycle2(head2));
		
		//160. Intersection of Two Linked Lists
		ListNode listA = new ListNode(4);
		listA.next = new ListNode(1);
		listA.next.next = new ListNode(8);
		listA.next.next.next = new ListNode(4);
		listA.next.next.next.next = new ListNode(5);
		ListNode listB = new ListNode(5);
		listB.next = new ListNode(6);
		listB.next.next = new ListNode(1);
		listB.next.next.next = listA.next.next;
		System.out.println(s.getIntersectionNode1(listA, listB) == listA.next.next);
	}
	
}

class Solution {
	
	long beforeMemory;
	long afterMemory;
	
	//121. Best Time to Buy and Sell Stock
	public int maxProfit(int[] prices) {
		
		int minPrice = prices[0];
		int profit = 0;
		
		for (int i = 1; i < prices.length; i++) {
			
			if (prices[i] < minPrice) {
				minPrice = prices[i];
			}
			
			if (prices[i] - minPrice > profit) {
				profit = prices[i] - minPrice;
			}
		}
		
		return profit;
	}
	
	//136. Single Number
	public int singleNumber1(int[] nums) {
		
		System.gc();
		beforeMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
		
		Map<Integer, Integer> map = new LinkedHashMap<Integer, Integer>();
		
		for (int i = 0; i < nums.length; i++) {
			
			int iNum = nums[i];
			
			Integer igNum = map.get(iNum);
			if (igNum == null) {
				map.put(iNum, iNum);
			} else {
				map.remove(iNum);
			}
		}
		
		Iterator<Integer> remainNum = map.keySet().iterator();
		if (remainNum.hasNext()) {
			
			System.gc();
			afterMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
			System.out.println((beforeMemory - afterMemory)/1024/1024 + " byte");
			
			return remainNum.next();
		} else {
			
			System.gc();
			afterMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
			System.out.println((beforeMemory - afterMemory)/1024/1024 + " byte");
			
			return 0;
		}
	}
	public int singleNumber2(int[] nums) {
		
		System.gc();
		beforeMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
		
		Map<Integer, Integer> map = new LinkedHashMap<Integer, Integer>();
		
		for (int i = 0; i < nums.length; i++) {
			
			int iNum = nums[i];
			
			Integer igNum = map.get(iNum);
			if (igNum == null) {
				map.put(iNum, 1);
			} else {
				map.put(iNum, ++igNum);
			}
		}
		
		for (Integer key : map.keySet()) {
			if (map.get(key) == 1) {
				
				System.gc();
				afterMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
				System.out.println((beforeMemory - afterMemory)/1024/1024 + " byte");
				
				return key;
			}
		}
		
		System.gc();
		afterMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
		System.out.println((beforeMemory - afterMemory)/1024/1024 + " byte");
		
		return 0;
	}
	//int 변수 선언 시
	public int singleNumber3(int[] nums) {
		
		System.gc();
		beforeMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
		
		int source = nums[0];
		
		for (int i = 1; i < nums.length; i++) {
			source ^= nums[i];
		}
		
		System.gc();
		afterMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
		System.out.println((beforeMemory - afterMemory)/1024/1024 + " byte");
		
		return source;
	}
	//변수 선언 없이 파라미터로 받은 nums 배열에 다시 초기화
	public int singleNumber4(int[] nums) {
		
		System.gc();
		beforeMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
		
		for (int i = 1; i < nums.length; i++) {
			nums[i] ^= nums[i - 1];
		}
		
		System.gc();
		afterMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
		System.out.println((beforeMemory - afterMemory)/1024/1024 + " byte");
		
		return nums[nums.length - 1];
	}
	
	//141. Linked List Cycle
	public boolean hasCycle1(ListNode head) {
		
		List<ListNode> listNode = new ArrayList<ListNode>();
		
		while (head != null) {
			
			if (listNode.contains(head)) {
				return true;
			}
			
			listNode.add(head);
			head = head.next;
		}
		
		return false;
	}
	public boolean hasCycle2(ListNode head) {
		
		while (head != null) {
			
			if (head.val == 1000000) {
				return true;
			}
			
			head.val = 1000000;
			head = head.next;
		}
		
		return false;
	}
	
	//160. Intersection of Two Linked Lists
	public ListNode getIntersectionNode1(ListNode headA, ListNode headB) {
		
		Map<Integer, ListNode> mapListNode = new LinkedHashMap<Integer, ListNode>();
		
		while (headA != null) {
			mapListNode.put(headA.val, headA);
			headA = headA.next;
		}
		
		while (headB != null) {
			if (headB == mapListNode.get(headB.val)) {
				return headB;
			} else {
				headB = headB.next;
			}
		}
		
		return null;
	}
	public ListNode getIntersectionNode2(ListNode headA, ListNode headB) {
		
		//listA, listB 전체 탐색 후 listB, listA를 연결하기 위해 headA, headB 객체를 유지한다.
		ListNode tmpA = headA, tmpB = headB;
		
		//두 Node가 같지 않으면 다음 노드끼리 비교한다(같지 않은 것이 반복문 수행 조건).
		while (tmpA != tmpB) {
			tmpA = (tmpA == null) ? headB : tmpA.next;
			tmpB = (tmpB == null) ? headA : tmpB.next;
		}
		//결합한 노드에서도 공통 노드를 찾지 못할 경우 tmpA == tmpB == null(tmpA와 tmpB 모두 null)로 반복문을 종료한다.
		
		return tmpA;
//		return tmpB;//tmpB를 반환해도 상관없다.
	}
	
}



나는 무엇을 원하는가?
1. 삶 전체로 봤을 때는 굴곡이 적고 무난하여 평온함을 느끼는 행복한 삶
2. 하지만 하루하루는 의미 있는 채움과 비움을 경험할 수 있는 삼

네트워크
웹 서버 하나를 정해놓고 공부한다. apache 또는 nginx 추천. 관련 서적으로 공부한다.
	웹 서버 :
프로젝트 관념(ideation) : 내가 달성하고 싶은 것은 정확히 무엇인가? 내 목적 달성을 웹사이트가 어떻게 돕는가? 목적 달성을 위해 무엇을, 어떤 순서로 해야할까?
생각을 현실로 만들 길의 탁 트인 전망을 얻으려면 앉아서 생각을 구조화해야한다. 이것을 하기 위해서, 오직 펜과 종이 그리고 적어도 다음 질문에 대한 답할 시간이 필요하다.
원하는 리스트를 만들고 나면, 우선순위를 정하는 것이 필요하다.
음악에 관련된 5개의 목표, 개인 삶에 관련된 하나의 목표 그리고, 완전히 상관없는 고양이 사진이라는 목표가 있다면,
이 모든 목표들을 다루기 위한 하나의 웹사이트를 만드는 것이 합리적입니까?
결국에, 많은 기존의 웹 서비스는 새로운 웹사이트를 만들지 않고 이 목표를 가져다 줄 수 있을지 모른다.
애인을 찾는 것은 새로운 웹사이트를 구축하는 것보다 기존의 자원을 사용하는 것이 더 알맞다는 점에서 중요한 케이스이다.
왜냐하면 우리가 실제로 애인을 찾는 것보다 웹사이트를 구축하고 유지하는 데 더 많은 시간을 소비하기 때문이다.
우리의 목표는 웹사이트를 구축하는 것이 아닌 애인을 찾는 것이고, 이것이 가장 중요하기 때문에, 우리는 처음부터 시작하는 것보다는 기존의 툴을 레버리징하는 것에 에너지를 써야한다.
음악과 연관된 5개의 목표.
목표를 충족시킬만한 웹서비스가 있다.
하지만, 우리만의 웹사이트는 하나의 공간에 퍼블리싱하고 싶은 모든 항목을 합치는 것과 그리고 우리와 대중 사이에 상호작용을 장려하는 것에 가장 좋은 방법이다.
다시 말해서, 이런 목표들이 같은 주제를 중심으로 돌기 때문에, 한 곳에 모든 것을 가지는 것이 우리의 목표를 충족하고, 팔로어들과 연결하는 데 도움이 될 것이다.
목표 1 : 사람들이 당신의 음악을 듣게 하기
해야할 것 : 1. 음악을 녹음한다. 2. 온라인에서 사용할 수 있는 몇몇의 오디오 파일을 준비한다. (기존의 웹 서비스로 이것을 할 수 있을까?) 3. 사람들에게 당신의 웹 사이트의 일부에서 당신의 음악에 접근하게 한다.
목표 2 : 음악에 대해 이야기하기
해야할 것 : 1. 토의를 시작하기 위한 몇몇의 글을 쓴다. 2. 어떻게 글이 보여야 하는 지 정해라. 3. 웹사이트에 이 글을 게시해라 (어떻게 이것을 할까?)
목표 3 : 다른 음악가들 만나기
해야할 것 : 1. 사람들이 너와 연락할 방법을 제공해라. 2. 너의 웹사이트에서 어떻게 사람들이 연락 채널을 찾을 지 정해라.
목표 4 : goodies 팔기
해야할 것 : 1. goodies 만든다. 2. goodies 저장한다. 3. 쇼핑을 하는 방식 찾는다. 4. 결제 방식 찾는다. 5. 사이트에서 사람의 주문 메카니즘 만든다.
목표 5 : 동영상을 통해 음악 가르치기
해야할 것 : 1. 동영상 강의 녹화한다. 2. 온라인에서 볼 수 있는 동영상 파일 준비한다. (다시, 기존의 웹사이트에서 할 수 있을까?) 3. 웹사이트의 한 부분에서 비디오 접근 가능하게 한다.
이런 아이템 중 몇몇은 웹과 상관이 없다. (예를 들어, 음악 녹음, 글 쓰기) 종종 그런 오프라인 활동이 프로젝트의 웹 부분보다 훨씬 중요하다. 예를 들어, 판매의 경우에 공급, 결제, 배달에 시간을 쓰는 것이 사람들이 주문할 수 있는 웹사이트를 만드는 것보다 훨씬 중요하다.
둘째, 실행가능한 단계를 설정하는 것이 우리가 답할 필요가 있는 새로운 질문을 이끌어 낸다. 종종 우리가 생각했던 것보다 더 많은 질문으로 변한다. (예를 들어, 내가 혼자서 어떻게 이것을 배워야할까? 누군가에게 이것을 부탁할까? 서드파티(제 3의) 서비스를 사용해야할까?)
"웹사이트를 만들고 싶다"라는 단순한 생각이 긴 해야할 목록을 만들었다. 그리고 그것은 생각하면 할 수록 더 길어진다. 겁먹지 마라. 모든 것을 해야할 필요는 없다. 중요한 것은 원하는 것과 도달하는 법에 대한 비전을 가지고 있어야하는 것이다.
일단 분명한 비전이 있다면, 당신은 해야할 때와 하는 방법을 결정할 필요가 있다.
큰 일을 작은 실행할 수 있는 단계로 부숴라. 그리고 그 작은 단계를 거대한 성과로 합쳐라.
인터넷은 어떻게 동작하는가?
네트워크
원하는 만큼의 컴퓨터를 연결할 수 있다. 그러나 컴퓨터가 많아질 수록 복잡해진다.
이 문제를 해결하기 위해 네트워크이 각 컴퓨터는 라우터라고하는 특수한 소형 컴퓨터에 연결된다. 이 라우터에는 단 하나의 작업만 있다. 주어진 컴퓨터에서 보낸 메시지가 올바른 대상 컴퓨터에 도착하는지 확인한다.
컴퓨터 B에게 메시지를 보내려면 컴퓨터 A가 메시지를 라우터로 보내야하며, 라우터는 메시지를 컴퓨터 B로 전달하고 메시지가 컴퓨터 C로 배달되지 않도록 해야한다.
집과 다른 지역 사이에, 아주 먼 곳에 네트워크를 연결하려면? 모뎀이라는 특수 장비를 이용해 전화 시설에 연결한다. 다음 단계는 우리의 네트워크에서 도달하려는 네트워크로 메시지를 보내는 것이다. 그렇게하기 위해 네트워크를 인터넷 서비스 제공 업체(Internet Service Provider, ISP)에 연결한다.
ISP는 모두 함께 연결되는 몇몇 특수한 라우터를 관리하고 다른 ISP의 라우터에도 액세스할 수 있는 회사이다. 따라서 우리 네트워크의 메시지는 ISP 네트워크의 네트워크를 통해 대상 네트워크로 전달된다. 인터넷은 이러한 전체 네트워크 인프라로 구성된다.
컴퓨터에 메시지를 보내려면 메시지를 받을 특정 컴퓨터를 지정해야한다. 따라서 네트워크에 연결된 모든 컴퓨터에는 IP 주소(IP는 인터넷 프로토콜을 나타냄)라는 고유한 주소가 있다. 그러나 IP 주소는 기억하기 어렵다. 그래서 우리는 '도메인 이름'이라고하는 사람이 읽을 수 있는 IP 주소의 이름을 지정할 수 있다.
예를 들어 'google.com'은 IP 주소로 '173.194.121.32' 이다. 
웹 브라우저를 사용하여 웹을 탐색할 때 일반적으로 도메인 이름을 사용하여 웹 사이트에 접속한다. 그것은 인터넷과 웹이 같은 것을 의미하는 것일까? 인터넷은 수십억 대의 컴퓨터를 모두 연결하는 기술 인프라이다. 이러한 컴퓨터들 중에 일부는 '웹 서버'로서 웹 브라우저가 이해할 수 있는 서비스를 제공한다.
인터넷은 인프라이며, 웹은 그 인프라 기반 위에 구축된 서비스이다. 웹 뿐만 아니라 인터넷 위에 구축된 다른 서비스들(이메일, IRC 등)도 있음을 알아야한다.
웹 페이지 : 파이어폭스, 구글 크롬, 오페라, MS 익스플로러나 엣지, 애플의 사파리 같은 웹 브라우저에서 보여지는 문서이다. 이런 것들을 단순히 "페이지"라고 하기도 한다.
웹사이트 : 다양한 방식으로 그룹으로 묶이거나 연결된 웹 페이지들의 모음이다. 보통 "웹사이트"나 "사이트"라고 한다.
웹 서버 : 인터넷에 웹사이트를 호스팅하는 컴퓨터이다. *호스팅 : 서버 컴퓨터의 전체 또는 일정 공간을 이용할 수 있도록 임대해주는 서비스를 말한다. 사용자가 직접 서버를 구입하고 운영할 필요 없이 호스팅 업체가 미리 준비해놓은 서버를 빌려 사용하는 형식이다.
도서관에 비유하면, 도서관은 웹 서버와 같다. 도서관은 여러 구역이 있는데, 이것은 다양한 웹사이트들을 호스팅하는 서버와 비슷하다.
도서관에 있는 과학, 수학, 역사와 같은 각기 다른 구역들은 웹사이트와 같다. 각각의 구역은 유일한 웹사이트이다. (두 개의 구역이 같은 책을 포함하지 않는다.)
구역에 있는 책들은 웹 페이지와 같다. 한 웹사이트는 여러 웹 페이지들을 가지고 있을 수 있다. 예를 들어, 과학 섹션(웹사이트)은 열, 소리, 열역학, 정역학 등의 책(웹 페이지)을 가지고 있을 것이다.
웹 페이지는 브라우저를 통해 보여지는 단순한 문서이다. 웹 페이지는 다양한 다른 종류의 자원을 포함할 수 있다. (style information-페이지의 외관와 느낌을 관리, scripts-페이지에 interactivity(대화식 이용)을 첨가, media-사진, 소리, 동영상)
웹사이트는 유일한 도메인 이름을 같이 사용하는 연결된 웹 페이지들의 모음이다.(관련된 자원도 포함된다.) 각각의 웹사이트에서 분명한 링크가 주어진 웹 페이지들은 유저가 그 웹사이트의 한 페이지에서 다른 페이지로 이동하게 한다.
웹 페이지와 웹사이트에 대한 생각은 특히 하나의 웹 페이지만 포함하는 웹사이트에서 혼동하기 쉽다. 이런 웹사이트를 보통 a single-page website라고 한다.
웹 서버는 한 개 이상의 웹사이트를 호스팅하는 컴퓨터이다. 호스팅은 모든 웹 페이지 및 웹 페이지가 지원하는 파일들을 컴퓨터에서 이용할 수 있다는 것을 의미한다. 웹 서버는 유저의 request마다 호스팅하는 웹사이트에서 유저의 브라우저로 웹 페이지를 보낼 것이다.
웹사이트와 웹 서버를 혼동하지 마라. 예를 들어, 당신이 누군가 "내 웹사이트가 반응하지 않는다."라고 말하는 것을 들었다면, 그것은 사실 웹 서버가 반응하지 않는다는 의미이다. 그리하여 웹사이트를 이욯하지 못하는 것이다. 웹 서버는 여러 웹사이트에 호스팅될 수 있기 때문에, 웹 서버라는 용어는 절대 특정 웹사이트를 지정하기 위해 사용하지 않는다.
웹 서버란 무엇일까?
"Web server"는 하드웨어, 소프트웨어 혹은 두 개가 같이 동작하는 것을 의미할 수 있다.
1. 하드웨어 측면에서, web server는 web server의 소프트웨어와 website의 컴포넌트 파일들을 저장하는 컴퓨터이다. (컴포넌트 파일에는 HTML 문서, images, CSS stylesheets, 그리고 JavaScript file이 있다.) Web server는 인터넷에 연결되어 웹에 연결된 다른 기기들이 웹 서버의 데이터를 주고받을 수 있도록 한다.
2. 소프트웨어 측면에서, web server는 기본적으로 웹 사용자가 어떻게 호스트 파일들에 접근하는지를 관리한다. HTTP 서버로 국한하면, HTTP 서버는 URL(Web addresses)과 HTTP(당신의 브라우저가 웹 페이지를 보여주기 위해 사용하는 프로토콜)의 소프트웨어 일부이다.
가장 기본적인 단계에서, 브라우저가 웹 서버에서 불려진 파일을 필요로 할때, 브라우저는 HTTP를 통해 파일을 요청한다. 요청이 올바른 웹 서버(하드웨어)에 도달했을때, HTTP 서버(소프트웨어)는 요청된 문서를 HTTP를 이용해 보내준다.
웹 사이트를 공개하기 위해서는, 정적 혹은 동적 웹 서버가 필요하다.
정적 웹 서버 혹은 스택은 HTTP 서버 (소프트웨어)가 있는 컴퓨터(하드웨어)로 구성되어 있다. 서버가 그 불려진 파일을 당신의 브라우저에게 전송하기 때문에 정적이라고 부른다.
동적 웹 서버는 정적 웹 서버와 추가적인 소프트웨어(대부분 일반적인 애플리케이션 서버와 데이터베이스)로 구성되어 있다. 애플리케이션 서버가 HTTP 서버를 통해 당신의 브라우저에게 불려진 파일들을 전송하기 전에, 애플리케이션 서버가 업데이트하기 때문에 동적이라고 부른다.
예를 들어, 당신이 브라우저에서 보는 최종 웹 페이지들을 생성하기 위해, 애플리케이션 서버는 아마 데이터베이스로 온 컨텐츠들로 이루어진 HTML 템플릿을 채룰지도 모른다. MDN 혹은 Wikipedia와 같은 사이트들은 수 천 개의 웹 페이지들을 가지고 있지만, 그것들은 실제 HTML 문서가 아니라 오직 약간의 HTML 템플릿과 엄청 큰 데이터베이스로 되어 있다. 이 구성은 내용을 전달하고 관리하기 쉽고 빠르게 만들어 준다.
	정적 웹 : 외부 환경에 관계 없이 일정한 결과값을 제공해주는 걸 의미한다. 대표적인 사레로 회사 소개 페이지로, 별다른 로그인이 없고 페이지는 어떤 디바이스, 상황에 상관 없이 항상 일정한 화면을 제공한다. 브라우저는 웹 서버와 통신해서 이미 저장되어 있던 HTML, CSS, JS파일을 다운받는다.
	여기서 웹 서버는 HTML, CSS, JS 저장소 역할을 하는 것으로 볼 수 있다. 따로 데이터베이스가 필요하거나, 비즈니스 로직이 필요하지 않다.
	동적 웹 : 외부 환경에 따라 다른 결과값을 제공해주는 걸 뜻한다. 동적 웹은 클라이언트의 요청에 따라 다양한 화면을 제공해준다. 예를 들어, 우리가 로그인한 후 마이페이지를 들어가면 각기 다른 정보를 확인할 수 있는 것이다. 이 경우에 웹 서버에서는 단순히 HTML, CSS, JS 파일만 제공해주는 것이 아니라 웹 어플리케이션 서버와 직접 통신을 한다.
	웹 어플리케이션 서버(Web Application Server, WAS)는 복잡한 비즈니스 로직, 데이터베이스와의 통신 등을 책임진다. 웹 서버는 WAS와 통신해서 얻은 결과 값을 바탕으로 가공 작업을 거쳐 최종적으로 만들어진 동적인 웹 파일을 클라이언트에게 전달한다.
	* 웹 어플리케이션 서버는 일종의 API 서버라고 볼 수 있다. 데이터베이스와 통신하며 데이터를 가공하고 전달해주는 역할도 하기 때문이다.
	그러나 사실 정적 웹을 다운받는 방식으로도 복잡한 어플리케이션을 구현할 수 있다. 일례로 정적인 웹을 다운받은 후 클라이언트(브라우저)에서 다른 서버와 통신을 통해 로그인, 상품 정보 불러오기, 결제하기 등의 작업을 수행할 수 있기 때문이다.
	즉 웹 서버에서 단순하게 웹 껍데기를 다운받은 후 브라우저에서 핵심 작업들을 전부 수행하는 것이다. 이런 작업 방식을 Client Side Rendering(CSR)이라고 부른다. 현재 웹 개발에 많이 사용되는 웹 프레임워크 React, Vue 등은 해당 방식으로 동작한다.
	* SSR vs CSR
	SSR(Server Side Rendering) : 클라이언트가 사이트에 들어오면, 서버에서 데이터를 가져와 페이지를 구성한 후 브라우저에 전달한다. 클라이언트가 페이즈를 이동(요청)할 때마다 서버에서 데이터를 불러와 다시 브라우저에게 모든 내용을 전달한다. 그래서 렌더링하지 않아도 되는 부분까지 렌더링되는 단점이 있다.
		동작 방식
		1. 사용자가 웹 페이지를 방문하면(request), 서버는 리소스를 확인하고 페이지 내에 있는 서버측 스크립트를 실행 후 HTML 컨텐츠를 컴파일 및 준비한다.
		2. 컴파일된 HTML은 추가 렌더링 및 표시를 위해 클라이언트 브라우저로 전송된다(response).
		3. 브라우저는 HTML을 다운로드하고 최종 사용자가 사이트를 볼 수 있도록 한다.
		4. 브라우저는 자바스크립트를 다운로드하고 실행하면서 페이지를 대화형(interactive)으로 만든다.
		5. 사용자가 페이지를 이동할 경우, 위 동작을 반복한다.
		장점
		1. 초기 페이지 로드 시간이 더 빠르다(FP-First Paint 및 FCP가 더 빠르다). 렌더링이 준비된 HTML 파일을 브라우저에서 로드하기 때문에 CSR에 비해 더 빠르다.
		2. 서버에서 페이지 로직 및 렌더링을 실행하면 많은 자바스크립트를 클라이언트에 보내지 않아도 되므로 TTI(Time to Interactive)를 빠르게 수행할 수 있다.
		3. SEO에 친화적이다. 이미 다 만들어진 페이지를 검색 엔진 크롤러가 요청에 대한 응답으로 받기 때문이다.
		4. 클라이언트 하드웨어 및 소프트웨어 성능에 영향을 덜 받는다. 일반적으로 서버는 더 높은 컴퓨팅 성능과 훨씬 더 높은 네트워킹 속도를 가진 시스템이다. 클라이언트에서는 서버가 완성된 페이지만 렌더링해주면 된다. 즉 클라이언트 부담이 CSR에 비해 덜 하다.
		단점
		1. 페이지 이동시마다 서버에서 페이지를 생성하는데 시간이 걸리기 때문에 TTFB(Time to First Byte)가 느리다.
		2. 페이지 로드가 너무 무겁다면, 오히려 사용자 경험을 개선하는게 아니라 해칠 수 있다. 초기 페이지 로드 시 데이터가 많이 필요한 대시보드가 예가 될 수 있다.
		3. 서버는 항상 각 요청이 올 때마다 HTML 파일을 생성하기 때문에 CDN 수준에서의 컨텐츠 캐시가 되지 않는다.
			*CDN(Content Delivery Network) : 지리적 제약 없이 전 세계 사용자에게 빠르고 안전하게 컨텐츠를 전송할 수 있는 컨텐츠 전송 기술. 데이터 사용량이 많은 애플리케이션의 웹 페이지 로드 속도를 높이는 상호 연결된 서버 네트워크.
			사용자가 웹 사이트를 방문할 때 해당 웹 사이트 서버의 데이터는 사용자의 컴퓨터에 도달하기 위해 인터넷을 통해 이동해야한다. 사용자가 해당 서버에서 멀리 떨어져 있는 경우 동영상 또는 웹 사이트 이미지와 같은 대용량 파일을 로드하는 데 시간이 오래 걸린다.
			대신 웹 사이트 콘텐츠는 지리적으로 사용자와 가까운 CDN 서버에 저장되며 컴퓨터에 훨씬 빨리 도달한다.
		4. 서버 호스팅이 필요하다. 클라이언트에서 자바스크립트을 이용해 렌더링하는 CSR에 비해 서버 사이드에서 HTML 파일과 안에 들어가는 내용들을 생성해야하기 때문에 서버 호스팅이 필요하다.
		5. CSR에 비해 더 많은 개발 노력이 필요하며, SSR 프레임워크를 사용한다면 추가적인 러닝 커브에 대한 비용이 발생한다.
			*러닝 커브(Learning Curve) : 학습 곡선. 특정 기술 또는 지식을 실제 필요한 업무와 같은 환경에서 효율적으로 사용하기 위해 드는 학습 비용을 의미하기도 하며 특정 기술을 습득할 때에 처음에는 학습 효과가 더디다가 어느 정도 이해를 하고나면 빠르게 습득하고 후데는 다시 더뎌지는 곡선을 나타낸다.
	CSR(Client Side Rendering) : 브라우저에서 JS를 다운받고, 리액트를 실행시킨다. 모든 로직과 데이터 가져오기, 템플릿, 라우팅과 같은 것들은 서버가 아닌 클라이언트에서 처리가 된다. 완전히 실행이 되면 사용자는 화면을 볼 수 있고, 작동시킬 수 있다.
	CSR은 보통 SPA(Single Page Application)에서 쓰이는 기법이다. 리액트로 만든 홈페이지에 들어가면, index.html을 다운받고, 그 안의 index.js 파일을 다운로드한다. 모든 코드들이 index.js 파일에 들어있기 때문에 처음에 번들된 이 파일을 다운받는데 시간이 꽤 걸릴 수 있다. (사용자들이 첫 화면을 보는데 시간이 걸릴 수 있다.)
	장점은 클라이언트가 페이지를 이동할 때 화면이 깜빡이지 않아도 바로 렌더링이 되는 사용성 측면에서의 장점과 서버에서는 데이터를 주고받는 일만 하면되니까 SSR보다 서버의 부하를 줄여줄 수 있는 성능 측면이 있다.
		동작 방식
		1. 사용자가 웹 페이지를 방문하면(request), 브라우저는 최소한의 HTML 파일을 다운로드(response)한다. 이 HTML 파일은 script, meta, link 등의 태그를 포함하며, 빈 컨텐츠의 index.html 파일이라고 보면 된다.
		2. 브라우저는 index.html에 있는 자바스크립트 번들 파일을 다운로드한 다음 AJAX를 통해 API 요청을 수행하여 동적 컨텐츠를 가져오고 파싱하여 최종 컨텐츠를 렌더링한다.
		3. 사용자가 페이지를 이동할 경우, 서버에 추가 HTML 파일을 요청하지 않고 이미 받은 자바스크립트를 이용하여 렌더링한다.
		장점
		1. 후속 페이지 로드 시간이 더 빠르다. CSR을 위해 모든 자원 스크립트가 사전에 로드되었기 때문에 CSR의 로드 시간이 줄어든다.
		2. 별도의 API를 호출할 필요가 없는 페이지이거나 지연 로딩 모듈이 필요하지 않다. 이미 스크립트가 캐싱된 경우 인터넷 없이도 해당 CSR 웹 어플리케이션을 실행할 수 있다.
		3. CSR은 서버를 호출할때마다 전체 UI를 다시 로드할 필요가 없다.
		단점
		1. 초기 페이지 로드 시간이 SSR에 비해 느리다. CSR을 사용하면 브라우저는 브라우저에서 사용 가능한 컨텐츠로 HTML을 컴파일하기 전에 기본 HTML, CSS 및 모든 필수 스크립트를 로드하기 때문이다.
		2. SEO(Search Engine Optimization)에 친화적이지 않다. 검색 엔진 크롤러가 해당 페이지에 처음 방문했을 때는 빈 페이지이기 때문에 이해할 수 없다. 물론 자바스크립트를 실행시킬 수 있는 구글 크롤러와 같은 검색엔진 크롤러가 등장하고 있기는 하지만, 아직 많은 검색 엔진 크롤러들이 지원하지 않는다.
		3. 페이지 메타데이터의 변경을 위한 추가적인 노력이 필요하다. 한 페이지에서 다른 페이지로 변할 경우 이를 인지시켜주기 위해 각 페이지에 대한 메타데이터를 설정하고, 클라이언트에서 렌더링하기 위해 추가적인 노력이 필요하다.
		4. 브라우저가 페이지를 표시하기 전에 HTML 및 JavaScript 파일을 다운로드하고 프레임워크를 실행하는 동안 사용자는 빈 페이지를 보고 있어야하므로 사용자 경험(UX)에 좋지 않다.
	SSG(Static Site Generator) : SSR처럼 서버로부터 완성된 HTML을 받아오지만, 다른 점은 HTML 파일의 생성시점이 빌드 타임이라는 것이다. 빌드 타임에 js를 변환하여 HTML을 미리 만들어 둔다. 그리고 요청이 들어오면 이미 완성된 HTML을 반환한다.
	static 메소드가 메모리에 할당되어 인스턴스 생성없이 호출할 수 있는 것처럼, 렌더링 또한 이미 완성되어 있는 HTML을 받아 처리되는 것 같다?
		동작 방식
		1. 사용자가 웹 페이지를 방문하면(request), 엣지 캐싱(edge caching)된 HTML을 클라이언트로 반환해준다.
			*엣지 캐싱 : 최종 사용자에게 더 가깝도록 컨텐츠를 저장하기 위해 캐싱 서버를 이용하는 것이다. 대표적으로 CDN을 많이 사용한다.
		2. 브라우저는 HTML을 다운로드하고 최종 사용자가 사이트를 볼 수 있도록 한다.
		장점
		1. 빌드 타임에 HTML 파일이 생성되기 때문에 빠른 FP, FCP, TTI를 제공한다. 또한 매 요청마다 생성하는 것이 아니므로, SSR과 달리 일관성있게 빠른 TFB를 달성할 수 있다.
		2. 이미 생성된 HTML 파일을 받기 때문에 SEO에 친화적이다.
		3. 빌드 명령은 실제로 사이트를 방문하는 사람의 워크플로를 벗어나므로 시간이 좀 걸리더라도 문제되지 않는다.
		단점
		1. 모든 URL에 대해 개별 HTTP 파일을 생성해야한다. 따라서 URL을 미리 예측할 수 없다면 적용이 어렵다.
호스팅 파일들
HTTP를 이용해 통신하기 : HTTP는 문자로 된, 독립적인 프로토콜이다. (Stateless(독립적인) : 서버 혹은 클라이언트는 이전의 통신을 기억하지 않는다. 예를 들어, HTTP에만 의존하면, 서버는 당신이 입력한 비밀번호 혹 당신이 처리한 단계를 기억하지 못한다. 당신은 그러한 일들을 위한 애플리케이션 서버가 필요하다.)
HTTP는 어떻게 클라이언트와 서버가 통신하는지 명확한 규칙을 제공한다.
오직 클라이언트만 HTTP 요청을 만들 수 있으며, 서버에게만 보낼 수 있다. 서버는 오직 클라이언트의 HTTP 요청에 응답할 수 있다.
HTTP를 통해 파일을 요청할 때, 클라이언트는 반드시 URL 파일을 제공해야한다.
웹 서버는 반드시 최소한의 에러 메시지를 포함하여 모든 HTTP 요청에 응답해야한다.
웹 서버에서, HTTP 서버는 들어오는 요청들에 대해 응답하고, 처리해야한다.
1. 요청을 받으면, HTTP 서버는 먼저 요청받은 URL이 존재하는 파일과 매칭이 되는지를 확인한다.
2. 만약 매칭된다면, 웹 서버는 그 파일 내용을 브라우저에게 되돌려준다. 만약 그렇지 않다면, 애플리케이션 서버는 필요한 파일을 구축한다.
3. 만약 위 둘의 과정이 불가능하다면, 웹 서버는 브라우저에 에러 메시지를 반환한다. 대부분의 에러 메시지는 "404 Not Found"이다.

운영체제
컴퓨터 사이언스 책(이른바 공룡책)과 '이것이 리눅스다!'라는 centos 리눅스 책 가지고 공부.
vmware를 이용하여 집에서도 리눅스 개발 환경을 구축. 최근에 느낀건데, vmware보다 virtualbox가 더 편한 것 같다.
리눅스 강의를 수강하여 공부.
리눅스에 대해 자신감이 붙었다하면 Docker 공부 추천. 그리고 AWS나 GCP 또는 Azure 해라. 능력되면 쿠버네티스.
LPIC 시험.

알고리즘 / 자료구조
1. 스택
2. 큐
3. 트리
4. 이진검색트리
5. 해쉬검색(체인법, 오픈어드레스법)
6. 퀵 정렬
7. 머지 정렬
8. 기수 정렬
9. 링크드 리스트(쌍방향까지)
언어는 C나 파이썬으로 공부. '열혈 자료구조' 같은 책으로 공부.
주니어에겐 알고리즘보다 디자인 패턴이 더 중요한 것 같다.
bigO에 대한 지식을 먼저 쌓아라.

보안
면접 어필용
1. XSS
2. CSRF
3. SQL injection
4. Open redirect
5. command injection
6. Directory Traversal
방어법까지 공부.
추가. authentication과 authorization의 차이를 명확하게 이해해라. 그리고 서버접근 제한, 로그인 비밀번호 암호화 방식 등 일상화되어 있는 기초 보안 지식.

데이터베이스
1. CRUD
2. index
3. explain
4. view
5. fail over
6. master-slave
7. replication
데이터베이스는 단일 항목으로보다 웹 서버부터 시작해서 애플리케이션 서버, 그리도 데이터베이스까지 오는 일련의 흐름을 제대로 이해하는게 중요.
특정 브라우저나 기기에서 던진 request가 어떤 프로토콜을 통해서, 어떤 라우팅을 통해서 어떻게 웹 서버에 도착하고 그것이 어떻게 redirect되서 데이터베이스까지 왔다가 물리적으로 저장된 데이터베이스 또는 메로리에 캐슁된 데이터를 뽑아가는 그 일련의 흐름.

디자인 패턴
일종의 손자병법. A같은 기능을 만들고 싶을 땐 이렇게 설계하면 되고, B같은 기능을 만들고 싶을 땐 이렇게 코딩하면 된다느 직접적 방법론을 제시해주는 가이드라인.

개발 패러다임
아키텍쳐 + 개발 프로세스
마이크로서비스 아키텍쳐, 애자일 개발방법론, 데브옵스에 의한 CI(또는 CD), 릴리즈 및 테스트 자동화 조합


추후 참고
- 어떻게 공부할까? 프로그래머 공부론
https://okky.kr/articles/398880
- 이력서(자기소개서)
한 줄 더 넣어서 안좋은 이력서가 되는 경우 (+ 무료로 이력서 첨삭해 드립니다)
- 포트폴리오
https://okky.kr/articles/1122716
- 면접
면접에서 들었던 & 했던 질문들

- doc
https://ui.toast.com/fe-guide/ko


멘토링
linkedin, facebook

퀵 소팅
1. 특정 기준 값을 잡아 기준 값보다 작은 값을 왼쪽, 큰 값들을 오른쪽에 집합시킨다.
2. 기준 값을 중심으로 2개로 집합을 분할한다.
3. 분할된 집합의 크기가 1 이하가 될 때까지 반복한다.

풀이
순차 소팅 : 첫 인덱스부터 집합의 요소 하나하나와 대소 비교를 통해 순서를 정렬
	- 복잡도(n개의 수) : 0번째 수 n-1번 비교 수행, 1번째 수 n-2번 비교 수행, ... n-1번째 수 1번 비교 수행, n번째 수 0번 비교 수행 = (n-1)*n/2
모든 경우를 비교하여 정렬하는 순차 소팅 대신 특정 값을 기준으로 크기가 작은 집합과 큰 집합을 분리하여 각각의 집합의 크기가 1 이하가 될 때까지 정렬을 반복하는 방법이 빠른 방법이 될 수 있다.
	- 복잡도(n개의 수) : 첫 번째로 집합을 나눈다 = 1회, 두 번째로 집합을 나눈다(첫 번째에서 나눠진 두 집합을 나눈다) = 2회, 세 번째로 집합을 나눈다(두 번째까지 나눠진 집합을 나눈다) = 4회, ... 1 + 2 + 4 + ...
	예)
	3개의 수 : 1 + (2개의 수 = 1회) = 2회
	4개의 수 : 1 + (3개의 수 = 2회) = 3회
	5개의 수 : 1 + (4개의 수 = 3회) = 4회
	= 결론 도출 : n개의 수를 두 집합으로 나누는 경우의 수 = n-1회(n-1개의 수는 n-2회, n-2개의 수는 n-3회, ... -1개의 수에 + 1회가 총 경우의 수이다.)

0 1 ... x x+1 x+2 ... y

1 9 8 2 3 7 7 6 4 5 - 10개의 수
임의의 기준 값 = 10 / 2 = 5번째 수 = 3
1 2 = 왼쪽 집합 (결과물 1) - 2개의 수
	임의의 기준 값 = 2 / 2 = 1번째 수 = 1
	없음 = 왼쪽 집합 (결과물 1) - 최종 결과물
	2 = 오른쪽 집합 (결과물 2) - 최종 결과물
9 8 7 7 6 4 5 = 오른쪽 집합 (결과물 2) - 7개의 수

퀵정렬 : 피벗을 설정하여 이를 올바른 위치로 이동시킨 뒤 나머지 원소들을 두 개의 배열로 분할하여 재귀적으로 정렬시키는 알고리즘.
	피벗 : 농구, 핸드볼, 배드민턴 따위의 구기나 댄스에서, 한 발을 축으로 하여 회전하는 일.
	pivot : 1. (회전하는 물체의 균형을 잡아 주는) 중심점[축], 2. (가장 중요한) 중심[중심축], 3. (축을 중심으로) 회전하다[돌다], 회전시키다[돌리다]
합병정렬과 달리, 배열이 불균등하게 분할된다.
	합병정렬(Merge sort) : 
	
	
		  분할
	분할			분할
분할		분할	분할		분할
	정복			정복
		  정복

1. WEB 서버와 WAS 서버

HRD-NET
청년 임대주택, 청년 기숙사
행복주택
청년 매입임대주택
청년전세임대주택
기숙사형 청년주택
주거급여(맞춤형 급여)
청년 사회적 주택
청년전용 버팀목전세자금
역세권 청년주택
운동 스마트워치 갤러리
https://zeddios.tistory.com/35

편한가계부
펜 추천 https://gall.dcinside.com/mini/board/view/?id=timer&no=1734


# java-junior
1544. Make The String Great

1. 인접한 알파벳이 각각 대소문자로 같은 알파벳인지 확인
 - 방법 :
  1. 비교할 알파벳을 toUpperCase() or toLowerCase()를 통해 같은 알파벳인지 판별 >> 같은 알파벳일지라도 대소문자가 변환되어 같은 것인지 변환되지 않고 모두 대문자 혹은 소문자로 같은 것인지 판별(변환 전 값과 변환 후 값 비교가 필요)
  2. 알파벳의 아스키 코드 값으로 알파벳 종류와 대소문자를 판별 + 같은 알파벳의 아스키 코드 값 차이는 32로 동일하므로 인접한 알파벳 아스키 코드 값 차이가 32인지 확인
 - 인접한 알파벳을 비교하는 방법
  1. for문
 
2. 같은 알파벳일 경우 두 알파벳을 문자열에서 제거
 - 방법 :
  1. String.substring한 값을 다시 String에 대입
  2. List에 제거 대상이 아닌 알파벳을 add하여 결과 값을 String으로 만듦(for문 필요)

*시나리오를 나눌 수 있는 방법
Input: s = "abBAcC"
Output: ""
Explanation: We have many possible scenarios, and all lead to the same answer. For example:
"abBAcC" --> "aAcC" --> "cC" --> ""
"abBAcC" --> "abBA" --> "aA" --> ""
 - 인접한 알파벳을 비교하는 방향을 어디에서부터 찾아나가는지에 따라 시나리오가 나뉘는 것으로 보인다. 방법의 차이는 아니라고 생각한다.

테스트 결과
 - 실패 1
  원인 : 문자열 제거 후 남은 앞의 알파벳과 뒤의 알파벳을 비교하는 로직을 고려하지 않았다. 즉, 현재 로직으로는 비교하고자 하는 알파벳이 통과할 경우 문자열 제거 후 새롭게 인접하게 된 알파벳과 새로 비교하는 로직이 누락되어 있다.
   - 방법 :
    1. 알파벳을 비교하는 for문을 완료한 후 알파벳이 제거된 새로운 결과가 나올 경우 다시 비교 for문을 수행한다. >> 문제 : 제거가 계속 수행되는 for문일 경우 반복문 수행을 계속 호출할 필요가 있는 재귀의 시간 복잡도를 갖게 된다.
	2. 문자열 제거가 일어난 시점에 새로 인접하게 될 두 알파벳을 비교한다.
	 2.1. i와 i+1의 알파벳이 제거됐을 경우 해당 시점의 i-1과 i+2를 비교한다. >> 문제 : 인접하게 될 알파벳이 계속해서 제거가 필요한 경우 마찬가지로 재귀의 시간 복잡도를 갖게 된다.
	 2.2. 문자열 제거 후 앞 문자열과 뒤 문자열을 합쳐 리턴한 문자열 s에서 제자리로 돌아와 반복문을 수행하는 것이 아닌 하나 이전의 인덱스에서 다시 비교를 시작한다. >> 반복문 수행 횟수는 경우에 따라 무한으로 늘어날 수 있지만 중첩이 아닌 단일한 반복문을 수행하므로 복잡도를 낮출 수 있을 것이다.
   
class Solution {
	public String makeGood(String s) {
		for (int i = 0; i <= s.length() - 2; i++) {
			char[] ca = s.toCharArray();
			int nAsciiCodeDiffVal = (char)ca[i] - (char)ca[i + 1];
			//수정1
			//굳이 char 배열 변수를 할당할 필요가 있을까?
//			nAsciiCodeDiffVal = s.substring(i, i + 1) - s.substring(i + 1, i + 2);
			//char 배열이 더 효율적으로 보임
			//아스키 코드 값으로 변환하기 위해서는 char형변환이 필요하며, substring의 경우 인덱스 오류 방지를 위해 조건문이 추가로 필요할 것으로 보이기 때문이다.
			if (nAsciiCodeDiffVal == 32 || nAsciiCodeDiffVal == -32) {
				//substring 인덱스 오류 방지
				String sFront = i == 0 ? "" : s.substring(0, i);
				String sBack = i == s.length() - 2 ? "" : s.substring(i + 2);
				//s에 다시 초기화하여도 새로운 s에 대해 새로운 인덱스로 반복문을 수행하기 때문에 새로운 변수에 할당할 필요가 없다.
				s = sFront + sBack;
//				System.out.println("i : " + i + ", s : " + s);
				//자른 문자열에 대해 현재 인덱스에서 다시 한 번 로직 수행
				//수정1
				//새로 인접할 알파벳(자르고 남은 앞 문자열의 마지막 알파벳과 뒷 문자열의 첫 알파벳) 간의 비교를 위해 한 칸 앞의 인덱스에서 다시 비교를 시작한다.
				//문자열 s의 첫 알파벳일 경우에는 앞 문자열이 없으므로 제자리로 돌아간다.
				i = i == 0 ? i - 1 : i - 2;
			}
		}
		
		return s;
	}
}


1. Two Sum
Input : int[] nums, int target
Output : int[] indexes(nums[indexes]의 합이 target이 되는 index 값들)
Constraint
1. return 값은 하나만 존재한다고 가정
2. 동일한 nums[indexes] 값을 두 번 사용할 수 없음
3.
 2 <= nums.length <= 104
 -10^9 <= nums[i] <= 10^9
 -10^9 <= target <= 10^9
 
Solution
1. int[] nums에서 두 요소를 추출하는 모든 경우의 수에서 그 합이 target이 되는 결과를 찾는다.
 >> nums.length의 최대값은 104(N)로 최대 경우의 수를 구하기 위해서는 104*103(N*(N-1))의 중첩 반복문을 수행해야 한다.
 이는 O(N^2)의 시간 복잡도를 갖게 되므로, 복잡도가 큰 방식이라 할 수 있다.

2. 어떠한 두 수를 더해 target 값이 되는 경우의 수에서 해당 두 수가 int[] nums의 요소인지 확인한다.
 >> -10^9 <= nums[i] <= 10^9, -10^9 <= target <= 10^9의 범위 조건에 따르면
 target의 최소값 -10^9는 nums[i] 범위에 따라 최소 -10^9와 최대 0의 범위 내 수의 합, -10^9+1은 최소 -10^9와 최대 1의 범위 내 수의 합, ..., 0은 최소 -10^9와 최대 10^9의 범위 내 수의 합, ..., 최대값 10^9는 최소 0과 최대 10^9의 범위 내 수의 합으로 만들어진다.
 따라서 target이 0이 될 때 두 수의 경우의 수는 최대가 된다.
 이처럼 두 수의 합의 경우의 수를 모두 계산하는 것 또한 1의 방법과 마찬가지로 높은 복잡도를 보일 것으로 보이며, 최소, 최대값에 따라 변하는 경우의 수를 모두 고려하는 것 또한 쉽지 않다고 생각한다.
 >> 다른 관점
 어떠한 두 수를 더해 target 값이 된다는 것은 target의 보수 개념에 해당한다.
 즉, 한 수가 정해질 경우 이 수에 대한 target의 보수는 자동으로 도출된다.
 따라서 int[] nums에서 i = 0부터 i++ 반복문에서 nums[i] 값에 대응하는 target의 보수 값을 찾고, 이 값이 int[] nums의 요소인지 확인하면 된다.
 >>> Condition
 if(nums.contain(target - nums[i])) //int[] 배열의 경우 요소가 존재하는지 확인하기 위해서는 직접 반복문에서 찾거나, String[] 혹은 List로 변환하여 찾아야 한다.
 -- 수정
 문제의 return 값은 indexes이므로, nums[indexes]와 indexes 값이 함께 저장되어야 한다. 따라서 Map을 활용하는 것이 좋다.
 Condition == true >> i와 Map에서 target - nums[i] 값을 target의 보수로 찾는 index(이전 요소에서 Map에 보수를 기록한 index)를 함께 return 한다.
 Condition == false >> i++ 하면서 다시 조건을 탐색한다. + i++ 하기 전에 보수 value와 i를 Map에 담는다.


20. Valid Parentheses
Input : String s
Output : boolean isValid
 Valid if
 1. 여는 괄호는 동일한 종류의 괄호로 닫아야 한다.
 2. 여는 괄호는 올바른 순서대로 닫아야 한다.
 3. 모든 닫는 괄호는 동일한 종류로 대응되는 여는 괄호가 있다.
 
Solution
먼저 s를 괄호 문자 하나씩 잘라 배열 형태로 만들어 반복문을 수행할 수 있게 한다.
0. s가 여는 괄호로 시작하는 지 확인한다.
1. 여는 괄호일 경우 그에 대응하는 닫는 괄호를 Stack에 넣는다.
2. 닫는 괄호일 경우 괄호가 순서에 맞게 닫고 있는지 확인하기 위해 Stack에서 peek() 메서드로 추출한 괄호와 비교한다.
비교하여 일치할 경우에는 순서와 종류에 맞는 닫는 괄호이므로 다음 반복문으로 넘어간다(Condition == true).
3. 규칙에 맞지 않는 괄호가 있을 경우 isValid = false 값을 반환하고 반복문을 종료한다(Condition == false).
4. return false 없이 반복문이 모두 수행됐다면, Stack이 모두 비워졌는지 확인하여 비워졌다면 return true, 아니면 return false 값을 반환한다.
 >>> Condition 1
 + 반복문에서 항상 조건을 탐색하지는 않는다. 여는 괄호일 경우와 닫는 괄호일 경우를 나눈다. 아래 조건은 닫는 괄호일 때만 수행하도록 조건문 내의 조건문으로 확인한다.
 if(bracket[i] == Stack.peek())
 Condition == true >> 다음 반복문 수행
 Condition == false >> isValid = false 값을 return
 >>> Condition 2
 if(Stack.isEmpty())
 Condition == true >> isValid = true
 Condition == false >> isValid = false


35. Search Insert Position
Input : int[] nums, int target
Output : int index(int[] nums에 요소로 target이 있을 경우 index, 없을 경우 target이 들어갈 때 위치할 index)

Solution >> Up-Down
1. int[] nums의 가운데 위치한 요소를 선택한다.
2. 선택한 요소와 target 값을 비교하여 같을 경우에는 해당 요소의 index를 반환한다.
3. 같지 않을 경우, target이 선택한 요소보다 작으면 처음부터 선택한 요소 - 1번째 요소까지로, 크면 선택한 요소 + 1번째부터 마지막 요소까지로 범위를 조정하여 1의 순서로 돌아가 반복문을 수행한다.
4. target과 같은 값의 요소가 없을 경우 범위 조정 과정에서 선택한 요소에 -1 혹은 + 1한 값이 범위 시작의 index 값보다 작아지거나 커진다(다시 말해, 범위 시작 index가 끝 index보다 작아질 수 있다).
즉, int[] nums에서 같은 값을 갖는 요소를 찾지 못해 범위 index의 역전이 발생하게 되는 것이다. 따라서 무한 반복의 종료를 해당 조건으로 판단한다.
 >>> Condition
 + start <= end이면 계속 반복
 if(nums[mid] == target) >> return mid
 else if(nums[mid] < target) >> start ~ mid-1 범위에서 다시 탐색
 else >> mid+1 ~ end 범위에서 다시 탐색
트리
 - 노드 : 동그라미. 보통 데이터가 담기는 곳
 - 엣지 : 노드와 노드 사이를 이어주는 선. 노드간의 관계
 - 경로 : 엣지로 연결된, 즉 인접한 노드들로 이뤄진 시퀀스. 경로의 길이는 경로에 속한 엣지의 수
 - 트리의 높이 : 루트 노드에서 말단 노드에 이르는 가장 긴 경로의 엣지 수.
 - 트리의 깊이 : 루트 노드에서 특정 노드까지 경로의 엣지 수. 특정 깊이를 가지는 노드의 집합을 레벨이라고 부른다.
 - 트리의 속성 중 가장 중요한 것은 '루트 노드를 제외한 모든 노드는 단 하나의 부모 노드를 가진다'는 것이다. 이 속성 때문에 트리는 다음 성질을 만족한다.
	- 임의의 노드에서 다른 노드로 가는 경로는 유일하다.
	- 회로(cycle)가 존재하지 않는다.
	- 모든 노드는 서로 연결되어 있다.
	- 엣지를 하나 자르면 트리가 두 개로 분리된다.
	- 엣지의 수는 노드의 수에서 1을 뺀 것과 같다
이진 트리 : 자식 노드가 최대 두 개인 노드들로 구성된 트리. 정이진트리(full binary tree), 완전이진트리(complete binary tree), 균형이진트리(balanced binary tree) 등이 있다.
 - 정이진트리 : 모든 레벨에서 노드들이 꽉 채워진(=잎새 노드를 제외한 모든 노드가 자식 노드 2개를 가짐) 이진트리
 - 완전이진트리 : 마지막 레벨을 제외한 모든 레벨에서 노드들이 꽉 채워진 이진트리
	- 정이진트리와 완전이진트리는 1차원 배열로도 표현이 가능하다.
 - 균형이진트리 : 모든 잎새 노드의 깊이 차이가 많아야 1인 트리. 예측 가능한 깊이를 가지며, 노드가 n개인 균형이진트리의 깊이는 log n을 내림한 값. => 모든 잎새 노드라는 표현은 적절하지 않을 것으로 보인다. 정확한 표현은 두 서브 트리의 깊이 차이가 1 이하인 트리 구조를 균형 이진트리라고 하며, 이를 균형이 잡힌 상태라고 부른다.
 다시 말해 깊이 차이가 2 이상인 경우에는 균형이 깨졌다고 하며, 이러한 구조의 트리는 회전을 통해 균형을 맞추는 작업을 거칠 수 있다.
 아마 균형이진트리에서 N개의 노드에 대한 시간 복잡도가 O(log N)이 나오는 것으로 보인다. 깊이 h에 대한 시간 복잡도 O(h)를 갖지만 일반적으로 데이터 수에 대한 복잡도를 나타내므로 h를 N 값으로 치환하면
 N <= 2^h-1 => h = log N+1 => O(h) = O(log N)
 
위 포화 이진트리(정 이진트리) 같은 경우에는 루트 노드를 1번으로 하고 레벨별로 왼편에서 오른 편오로 차례로 노드 위치에 번호를 2^(h+1)-1까지 부여가 가능하다.
그런데 만일 높이가 h이고 노드 수가 n, 일때 n<=(2^(h+1)-1)인 이진트리를 노드의 레벨 순수에 따라 노드 번호를 붙인다면 이때 각 노드 번호의 위치가 포화 이진트리 번호 1에서 n까지의 위치와 모두 정확하게 일치한다면 이 트리를 완전 이진트리라고 한다.
즉 루트 노드를 1이라고 하고 그외에 모든 노드가 왼쪽에서부터 오른쪽까지 꽉 차서 노드의 수가  n<=()라면 완전 이진트리이다. 아래 그림은 완전 이진트리의 예이다.


70. Climbing Stairs
Input : int n(계단 수)
Output : int numberOfCases
Constraint
1. 계단은 1계단 혹은 2계단 오를 수 있다.

Solution
1. 1과 2를 조합하여 숫자 n을 만드는 경우의 수 : n = 1*a + 2*b(a <= n까지 n번의 반복문)
반복문 내에서 1과 2를 나열하는 경우의 수를 연산하여 총 경우의 수를 누적한다.
2. 
n = 1일 때 계단을 오르는 경우의 수 -> n = 2일 때 계단을 오르는 경우의 수는 1계단에서 1 step 하는 경우와 0계단에서 2 step 하는 경우의 합으로 구해진다
-> n = 3일 때의 경우의 수는 마찬가지로 1계단에서 2 step 하는 경우와 2계단에서 1 step 하는 경우의 수로 구해진다 -> 이렇게 n은 마지막 계단을 1 step 오르는 경우와 2 step 오르는 경우의 합으로 구해지며 이는 n-1과 n-2 계단의 경우의 수 합으로 구할 수 있다.
>>
우선 인덱스 대신 계단 개수로 표기하면
[0]
[1] = 1
[2] = [1] + 1
[3] = [2] + [1]
...
[n] = [n-1] + [n-2] => 즉 1부터 n-1까지의 경우의 수 값이 저장되어 있어야 하며, 1부터 n까지 경우의 수 계산을 수행한다.
 >> Condition
 반복 : n까지
 종료 조건 : 없음
 수행 : [n] = [n-1] + [n-2]


94. Binary Tree Inorder Traversal
Input : TreeNode root
Output :

Solution
*
Preorder Traversal
InOrder Traversal
Postorder Traversal


101. Symmetric Tree
Input : TreeNode root
Output : boolean isSymmetric

Solution
1. 주어진 배열을 트리 깊이에 따라 가상으로 자른다(나눈다, 그룹핑한다).
같은 그룹 내에서 대칭인지 확인한다.
 예상 시간 복잡도 : 깊이 * 동일 깊이 내 모든 노드(혹은 모든 노드의 1/2)에 연산 필요 = h * 2^(h-1) = logN * 2^(logN - 1)
 
2. 순회(탐색)으로 도출한 값들을 Queue에 넣는다.
역순회(탐색)를 수행하면서 Queue에서 값들을 하나씩 비교하여 서로 일치하는 지 확인한다(대칭이라면 역순회로 도출해도 순회에서 먼저 들어간 값이 먼저 나와야 하므로 FIFO)
단, 순회 시 root까지만 수행한다.
 예상 시간 복잡도 : 균등 노드일 때 깊이 h에 대하여 1/2logN의 연산은 수행할 것으로 보이므로 O(logN)의 시간 복잡도를 보인다.
 도출한 값을 저장할 Queue에 대한 추가 공간이 필요하다.
 >> Condition 1
 수행 : 순회(조건 없음)
 >> Condition 2
 수행 : 역순회
 종료 조건 : 역순회에서 탐색한 값이 Queue.poll()한 값과 일치할 경우 다음 순회 진행, 일치하지 않을 경우 isSymmetric = false return


104. Maximum Depth of Binary Tree
Input : TreeNode root
Output : int maxDepth

Solution
* Tree 구조에 대한 이해
Tree 객체는 멤버변수로 Tree 객체를 갖는 구조이다.
즉 특정 Node에 로직을 적용할 경우, 그 Node의 멤버변수인 하위 노드를 참조하여 동일하게 적용할 수 있다.
root Node인 Top부터 하위로 이어지는 Down 방식인 재귀식 구현 방식을 생각해볼 수 있다.
1. maxDepth를 return 하는 메서드에 root 인자를 던질 경우 root Node의 left, right 노드인 TreeNode 객체를 다시 인자로 던지는 maxDepth 메서드를 호출하는 재귀식을 구현한다.
2. maxDepth를 return 해야 하므로 left route와 right route 중 더 큰 값을 return 하는 Math.max() 메서드를 활용한다.
 >> Condition 1
 수행 : 순회
 조건 : 인자로 받은 TreeNode 객체가 null이 아닐 경우(최하위 노드까지 수행)
 Condition == true >> 자기 자신을 depth = 1로 계산하고, 하위 노드의 maxDepth로 얻은 값을 더하여 return 한다.
 Condition == false >> 더 이상 Node가 없으므로 0을 return 한다.


108. Convert Sorted Array to Binary Search Tree
Input : int[] nums
Output : TreeNode tnBST

Solution
1. 균형 이진 트리를 만들기 위해 배열의 mid index를 value로 초기화하고 index를 기준으로 왼쪽 요소는 left TreeNode로, 오른쪽 요소는 right TreeNode로 배치하면 된다.
그래야만 가장 하위 노드가 1개만 남더라도 높이 차이가 1인 균형 이진 트리로 구성된다.
따라서 index를 기준으로 value, left, right를 초기화하고 left, right의 경우 재귀 함수로 수행하도록 한다.
 >> Condition
 if(nums.length > 0)
 Condition == true >> value, left, right 초기화
 Condition == false >> return ?? >> Solution에서 요구하는 sortedArrayToBST 메서드는 TreeNode 객체를 반환한다. 재귀 함수의 결과 역시 TreeNode 객체를 반환해야 최종 TreeNode 객체가 완성될 것이며, 따라서 재귀 함수에는 추가적으로 TreeNode 객체를 인자로 넘겨주어야 한다.
 이는 노드에 대한 하위 노드를 재귀적으로 초기화해줘야 Tree 구조를 완성할 수 있기 때문이기도 하다.
 -- 수정
 메서드 인자로 넘길 배열의 index 정보만 넘겨줘도 해당 메서드 내에서 생성하여 return한 TreeNode 객체로 left, right를 초기화하는 것이기 때문에 넘겨줄 필요가 없다.


118. Pascal's Triangle
Input : int numRows
Output : List<List<Integer>> pascalTriangle

Solution
1. 가장 위 꼭지점부터 numRows 개수만큼 삼각형을 크기를 키운다고 생각한다.
n행 m열의 값음 n-1행 m열의 값과 n-1행 m+1열의 값이 더해져 초기화된다.
 >> Condition
 for (i = 1; i <= numRows; i++) 반복문 수행
 수행 : 1부터 numRows까지의 각 행은 행 숫자만큼 열의 크기를 갖는다. 따라서 j는 1부터 numRows까지의 내부 반복문이 필요하다. -- 수정 : numRows까지일 경우 모든 층의 열을 동일하게 수행하므로 삼각형 모양이 아닌 사각형 모양이다. j 값은 i 값에 따라 변동되어야 한다.
 내부 반복문에서는 실제 n행 m열에 들어갈 값을 i, j 값으로부터 도출한다.
 그러기 위해서는 i와 j가 시작하는 행과 열에 대한 초기화가 필요하며, 이 값은 1이다.


121. Best Time to Buy and Sell Stock
Input : int[] prices >> Output : int maxProfit
Flow
1. prices 배열에서 ith day에 해당하는 가격에 주식 한 주를 구입한다.
2. i보다 큰 yth day의 주식 가격에 팔았을 때 차액이 가장 큰 경우를 구한다.
 2.1. 차액이 모두 마이너스일 경우 주식 거래가 일어나지 않는다고 결론 짓고 0을 반환한다.

Solution
Flow 1 : day i 선택
Flow 2 : day i 선택에 따른 day y 선택
1. 0부터 차례대로 넘어가며 전 값보다 작아지는 i 선택. 이후에는 플러스 차액을 기록. 계속 진행하며 i보다 작은 값이 나온다면? 1. 최대 차액이 그 전에 나온다. 2. 최대 차액이 그 후에 나온다. 그냥 최소 값 변수와 차액 변수만 가지고 있으면 비교 조건으로 최대 차액을 구할 수 있다고 생각.


★★
136. Single Number
Input : int[] nums >> Output : int singleElementNumber
★★
Constraints
use only constant extra space : 의미를 잘 모르겠다.
Flow
1. nums element가 처음 나왔는가? true >> 일단 저장, false >> 저장되어 있는 element 제거 후 통과
2. 저장한 공간에 남은 숫자를 반환한다.

Solution
1.
Flow 1 : i = 0부터 Map에 i 값을 key로 하는 element를 찾는다. 없으면 add() 하고, 있으면 remove() 한다.
Flow 2 : Map에서 keySet()으로 남은 key 값을 찾아 해당 key 값을 반환한다.
2.
Flow 1-1 : i = 0부터 Map에서 i 값을 key로 하는 value에 count를 1씩 증가시키는 반복문을 수행한다(nums 요소 전체 수행하여 다음 번 탐색을 위한 준비)
Flow 1-2 : i = 0부터 i 값을 key로 Map의 value를 찾아 value가 1인 key 값을 찾아 반환한다.
★★
XOR 비트 논리 연산자 활용
정수를 비트(2진수로) 표현하면 2^0 2^1 2^2 ... 2^n 형태가 된다.
^ 연산자(XOR 연산자)는 승에 해당하는 0 1 2 ... n의 비트끼리 연산하여 값이 같으면 0, 다르면 1을 반환한다.
nums 요소는 조건에 따라 쌍을 이루는 수를 제외한 나머지 한 개의 수가 남게 되는데,
이는 ^ 연산자로 표현할 경우 각 승에 해당하는 비트에서 쌍을 이루는 값을 제외한 나머지 하나의 값으로 구할 수 있게 된다.
예를 틀어 2^0 비트에 해당하는 곳에 3개의 수가 각각 0, 0, 1의 값일 경우 0 ^ 0 = 0, 0 ^ 1 = 1이 되어 쌍이 아닌 수 1이 결과 값과 일치하는 것을 볼 수 있다.
만약 비트 한 자리에 모두 수가 같은 경우에는 ^ 연산자에 따라 0 ^ 0 ^ 0 = 0, 1 ^ 1 ^ 1 = 1(1 ^ 1 = 0, 0 ^ 1 = 1)이므로 해당 자리에 대해서도 같은 결과 값을 얻을 수 있다.
이로 보아 ^ 연산자는 쌍으로 존재하는 수 가운데 유일하게 한 개의 수가 있을 경우 해당 수를 도출하는 데 사용할 수 있는 연산자의 개념이 된다.


141. Linked List Cycle
Input : ListNode head, (int pos - 제시되지만 메서드 호출 시 파라미터로 넘기지 않음) >> Output : boolean hasCycle
Flow
1. pos 값이 0 ~ head.size() - 2 사이의 값인가? hasCycle = true, 아니면 false
-- 수정 pos 값은 파라미터로 넘기지 않는다. 즉, pos 값과 관계없이 조건으로 true or false를 결정할 수 있는 포괄적 규칙을 생성해야 한다.
>> ListNode 클래스는 다음 노드인 ListNode next 클래스를 변수로 가지고 있다.
무한으로 next에 접근하여도 null이 아닐 경우 cycle을 가지고 있다고 할 수 있다. 만약 cycle 없이 무한으로 연결되어 있는 ListNode라면?? ListNode 클래스를 element로 갖는 List에 head부터 지나온 노드를 담고 next를 수행하면서 List에 있는 노드와 비교하여 같은 경우 cycle을 판단한다.
★★
지나온 노드에 Flag를 표시한다.
ListNode에는 boolean형 변수가 없기 때문에 true/false 개념의 flag 형태를 표시할 수는 없다. 따라서 제시된 문제의 제약 조건을 활용한다.
문제에서 제시된 조건은 -10^5 <= Node.val <= 10^5의 범위이므로 지나온 Node.val에 범위 밖의 숫자를 초기화한 뒤 next Node의 val 값이 범위 밖의 숫자에 해당하는지 확인하면 된다.
범위 밖의 숫자라면 내가 지나오면서 강제로 넣어준 값이므로 다시 돌아왔다는 의미기 때문에 순환한다고 할 수 있다.


160. Intersection of Two Linked Lists
Input : ListNode listA, ListNode listB, (int intersectVal - input으로 주어지지 않는다.) >> Output : ListNode intersectListNode
Flow
1. listA 노드와 listB 노드 간의 직접 비교 : listA 노드 수를 a, listB 노드 수를 b라고 하면 매칭 여부를 계산하기 위해서는 a*b번의 수행이 필요하다.
2. listA 노드 전체를 int val와 ListNode next를 key와 value로 하는 Map에 담는다. 모두 담은 후에 listB 노드 중 Map에서 매칭되는 노드가 있는지 확인 후 가장 먼저 매칭되는 Node를 반환한다.
★★
공통의 노드로 합쳐질 경우 공통 노드의 길이는 같다는 점을 이용한다.
listA와 listB의 길이는 같다는 보장이 없기 때문에 A, B 각각의 전체 노드에서 공통 노드가 시작되는 지점은 다를 수 있다.
하지만 listA에 listB를 결합한 것과 listB에 listA를 결합한 것의 전체 노드 길이는 동일하다. 결합한 두 노드는 끝 부분이 listA와 listB와 같으므로 결합한 노드를 비교하는 것과 A, B 노드를 비교하는 것이 같은 셈이다.
결합한 노드의 길이는 같기 때문에 전체 노드에서 공통 노드가 시작되는 지점은 같아지게 된다.
따라서 이 intersectVal을 찾으면 된다.


169. Majority Element

Given an array nums of size n, return the majority element.

The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.

 

Example 1:

Input: nums = [3,2,3]
Output: 3
Example 2:

Input: nums = [2,2,1,1,1,2,2]
Output: 2
 

Constraints:

n == nums.length
1 <= n <= 5 * 104
-109 <= nums[i] <= 109


AsFullHalf
가득찬 반만큼, 가득채운 반만큼, 가득한 반
fullful
fully
fullsomehalf
fullant
fullent
풀풀하
뿔뿔하
fullsh
fshalf150


<다이소>
뚜껑 수납함 https://ohou.se/advices/5976
주방템 https://sosovel-home.tistory.com/entry/%EB%8B%A4%EC%9D%B4%EC%86%8C-%EC%B6%94%EC%B2%9C%ED%85%9C-%EC%A3%BC%EB%B0%A9%ED%85%9C-5%EA%B0%80%EC%A7%80-%EC%B6%94%EC%B2%9C%EC%A3%BC%EB%B0%A9%ED%83%80%EC%9D%B4%EB%A8%B8-%EC%99%B8-%EB%8B%A4%EC%9D%B4%EC%86%8C-%EA%BF%80%ED%85%9C-%EC%82%AC%EC%9A%A9-%ED%9B%84%EA%B8%B0
다이소 블로그 https://brunch.co.kr/keyword/%EB%8B%A4%EC%9D%B4%EC%86%8C
다이소 꿀템
https://souhn2.tistory.com/entry/%EB%8B%A4%EC%9D%B4%EC%86%8C-%EC%97%90-%EC%82%B6%EC%9D%98-%EC%A7%88%EC%9D%84-%EB%86%92%EC%97%AC-%EC%A4%80%EB%8B%A4%EB%8A%94-%EB%8B%A4%EC%9D%B4%EC%86%8C-%EA%BF%80%ED%85%9C-10%EA%B0%80%EC%A7%80%EB%A5%BC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90
https://awesomeissuetree.co.kr/%EB%8B%A4%EC%9D%B4%EC%86%8C-%EA%B0%94%EB%8A%94%EB%8D%B0-%EC%95%88-%EC%82%AC%EB%A9%B4-%ED%9B%84%ED%9A%8C%ED%95%98%EB%8A%94-%EB%AC%BC%EA%B1%B4-top3/
https://jpddung.tistory.com/222

<네트망 인테리어>

<프린터 브랜드 비교>



package com.lg.zz;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

public class SolutionTest
{
	
	public static void main(String[] args)
	{
		Solution s = new Solution();
		long startTime;
		long endTime;
		//121. Best Time to Buy and Sell Stock
//		int[] prices1 = {7,1,5,3,6,4};
//		System.out.println(s.maxProfit(prices1));
//		int[] prices2 = {7,6,4,3,1};
//		System.out.println(s.maxProfit(prices2));
		
		//136. Single Number
//		int[] nums1 = {2,2,1};
//		//1
//		startTime = System.nanoTime();
//		System.out.println(s.singleNumber1(nums1));
//		endTime = System.nanoTime();
//		System.out.println((endTime - startTime) * 1e-9 + " sec.");
//		//2
//		startTime = System.nanoTime();
//		System.out.println(s.singleNumber2(nums1));
//		endTime = System.nanoTime();
//		System.out.println((endTime - startTime) * 1e-9 + " sec.");
//		//3
//		startTime = System.nanoTime();
//		System.out.println(s.singleNumber3(nums1));
//		endTime = System.nanoTime();
//		System.out.println((endTime - startTime) * 1e-9 + " sec.");
//		//4
//		startTime = System.nanoTime();
//		System.out.println(s.singleNumber4(nums1));
//		endTime = System.nanoTime();
//		System.out.println((endTime - startTime) * 1e-9 + " sec.");
		/*
			1
			0.0013297 sec.
			0 byte
			1
			1.121E-4 sec. = 0.0001121 sec.
			0 byte
			1
			8.690000000000001E-5 sec. = 0.0000869 sec.
			0 byte
			1
			6.400000000000001E-5 sec. = 0.000064 sec.
			0 byte
		 */
//		int[] nums2 = {4,1,2,1,2};
//		//1
//		startTime = System.nanoTime();
//		System.out.println(s.singleNumber1(nums2));
//		endTime = System.nanoTime();
//		System.out.println((endTime - startTime) * 1e-9 + " sec.");
//		//2
//		startTime = System.nanoTime();
//		System.out.println(s.singleNumber2(nums2));
//		endTime = System.nanoTime();
//		System.out.println((endTime - startTime) * 1e-9 + " sec.");
//		//3
//		startTime = System.nanoTime();
//		System.out.println(s.singleNumber3(nums2));
//		endTime = System.nanoTime();
//		System.out.println((endTime - startTime) * 1e-9 + " sec.");
//		//4
//		startTime = System.nanoTime();
//		System.out.println(s.singleNumber4(nums2));
//		endTime = System.nanoTime();
//		System.out.println((endTime - startTime) * 1e-9 + " sec.");
		
		//141. Linked List Cycle
//		ListNode head1 = new ListNode(3);
//		head1.next = new ListNode(2);
//		head1.next.next = new ListNode(0);
//		head1.next.next.next = new ListNode(-4);
//		head1.next.next.next.next = head1.next;
//		System.out.println(s.hasCycle1(head1));
//		ListNode head2 = new ListNode(1);
//		head2.next = new ListNode(2);
//		System.out.println(s.hasCycle1(head2));
//		System.out.println(s.hasCycle2(head1));
//		System.out.println(s.hasCycle2(head2));
		
		//160. Intersection of Two Linked Lists
		ListNode listA = new ListNode(4);
		listA.next = new ListNode(1);
		listA.next.next = new ListNode(8);
		listA.next.next.next = new ListNode(4);
		listA.next.next.next.next = new ListNode(5);
		ListNode listB = new ListNode(5);
		listB.next = new ListNode(6);
		listB.next.next = new ListNode(1);
		listB.next.next.next = listA.next.next;
		System.out.println(s.getIntersectionNode1(listA, listB) == listA.next.next);
	}
	
}

class Solution {
	
	long beforeMemory;
	long afterMemory;
	
	//121. Best Time to Buy and Sell Stock
	public int maxProfit(int[] prices) {
		
		int minPrice = prices[0];
		int profit = 0;
		
		for (int i = 1; i < prices.length; i++) {
			
			if (prices[i] < minPrice) {
				minPrice = prices[i];
			}
			
			if (prices[i] - minPrice > profit) {
				profit = prices[i] - minPrice;
			}
		}
		
		return profit;
	}
	
	//136. Single Number
	public int singleNumber1(int[] nums) {
		
		System.gc();
		beforeMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
		
		Map<Integer, Integer> map = new LinkedHashMap<Integer, Integer>();
		
		for (int i = 0; i < nums.length; i++) {
			
			int iNum = nums[i];
			
			Integer igNum = map.get(iNum);
			if (igNum == null) {
				map.put(iNum, iNum);
			} else {
				map.remove(iNum);
			}
		}
		
		Iterator<Integer> remainNum = map.keySet().iterator();
		if (remainNum.hasNext()) {
			
			System.gc();
			afterMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
			System.out.println((beforeMemory - afterMemory)/1024/1024 + " byte");
			
			return remainNum.next();
		} else {
			
			System.gc();
			afterMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
			System.out.println((beforeMemory - afterMemory)/1024/1024 + " byte");
			
			return 0;
		}
	}
	public int singleNumber2(int[] nums) {
		
		System.gc();
		beforeMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
		
		Map<Integer, Integer> map = new LinkedHashMap<Integer, Integer>();
		
		for (int i = 0; i < nums.length; i++) {
			
			int iNum = nums[i];
			
			Integer igNum = map.get(iNum);
			if (igNum == null) {
				map.put(iNum, 1);
			} else {
				map.put(iNum, ++igNum);
			}
		}
		
		for (Integer key : map.keySet()) {
			if (map.get(key) == 1) {
				
				System.gc();
				afterMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
				System.out.println((beforeMemory - afterMemory)/1024/1024 + " byte");
				
				return key;
			}
		}
		
		System.gc();
		afterMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
		System.out.println((beforeMemory - afterMemory)/1024/1024 + " byte");
		
		return 0;
	}
	//int 변수 선언 시
	public int singleNumber3(int[] nums) {
		
		System.gc();
		beforeMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
		
		int source = nums[0];
		
		for (int i = 1; i < nums.length; i++) {
			source ^= nums[i];
		}
		
		System.gc();
		afterMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
		System.out.println((beforeMemory - afterMemory)/1024/1024 + " byte");
		
		return source;
	}
	//변수 선언 없이 파라미터로 받은 nums 배열에 다시 초기화
	public int singleNumber4(int[] nums) {
		
		System.gc();
		beforeMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
		
		for (int i = 1; i < nums.length; i++) {
			nums[i] ^= nums[i - 1];
		}
		
		System.gc();
		afterMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
		System.out.println((beforeMemory - afterMemory)/1024/1024 + " byte");
		
		return nums[nums.length - 1];
	}
	
	//141. Linked List Cycle
	public boolean hasCycle1(ListNode head) {
		
		List<ListNode> listNode = new ArrayList<ListNode>();
		
		while (head != null) {
			
			if (listNode.contains(head)) {
				return true;
			}
			
			listNode.add(head);
			head = head.next;
		}
		
		return false;
	}
	public boolean hasCycle2(ListNode head) {
		
		while (head != null) {
			
			if (head.val == 1000000) {
				return true;
			}
			
			head.val = 1000000;
			head = head.next;
		}
		
		return false;
	}
	
	//160. Intersection of Two Linked Lists
	public ListNode getIntersectionNode1(ListNode headA, ListNode headB) {
		
		Map<Integer, ListNode> mapListNode = new LinkedHashMap<Integer, ListNode>();
		
		while (headA != null) {
			mapListNode.put(headA.val, headA);
			headA = headA.next;
		}
		
		while (headB != null) {
			if (headB == mapListNode.get(headB.val)) {
				return headB;
			} else {
				headB = headB.next;
			}
		}
		
		return null;
	}
	public ListNode getIntersectionNode2(ListNode headA, ListNode headB) {
		
		//listA, listB 전체 탐색 후 listB, listA를 연결하기 위해 headA, headB 객체를 유지한다.
		ListNode tmpA = headA, tmpB = headB;
		
		//두 Node가 같지 않으면 다음 노드끼리 비교한다(같지 않은 것이 반복문 수행 조건).
		while (tmpA != tmpB) {
			tmpA = (tmpA == null) ? headB : tmpA.next;
			tmpB = (tmpB == null) ? headA : tmpB.next;
		}
		//결합한 노드에서도 공통 노드를 찾지 못할 경우 tmpA == tmpB == null(tmpA와 tmpB 모두 null)로 반복문을 종료한다.
		
		return tmpA;
//		return tmpB;//tmpB를 반환해도 상관없다.
	}
	
}
