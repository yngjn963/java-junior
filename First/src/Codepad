public static void Star()
	{
//				*      
//			  * * *    
//			* * * * *  
//		  * * * * * * *
		long start = System.nanoTime();
		for (int i = 1; i <= 4; i++) {
			for (int j = 1; j <= 7; j++) {
				if (j <= (4 - i) || (8 - j) <= (4 - i)) {
					System.out.print(" ");
				} else {
					System.out.print("*");
				}
				if (j != 7) {
					System.out.print(" ");
				}
			}
			System.out.println();
		}
		long end = System.nanoTime();
		System.out.println("Test1 : " + (end - start) * 1e-9 + " sec.");
		System.out.println();
		//다른 방법1 - 열의 가운데까지 찍고 오른쪽에 나머지 별을 찍는다.
//		    *      
//		  * *		+		 *    
//		* * *		+		 * *  
//	  * * * *		+		 * * *
		//이렇게 하면 열의 가운데를 기준으로 오른쪽은 별이 없는 부분은 안찍어도 되지만, 조건문이 복잡해진다.
		//또한, 내부 반복문이 첫 번째 else절의 조건은 위의 if절에서 구현이 가능하기 때문에 불필요하다.
		start = System.nanoTime();
		for (int i = 1; i <= 4; i++) {
			for (int j = 1; j <= 7; j++) {
				if (j <= 4) {
					if (j >= 5 - i) {
						System.out.print("*");
					} else {
						System.out.print(" ");
					}
				} else {
					if (j <= 4 + (i - 1)) {
						System.out.print("*");
					}
				}
//				System.out.print("*");
				if (j != 7) {
					System.out.print(" ");
				}
			}
			System.out.println();
		}
		end = System.nanoTime();
		System.out.println("Test1 : " + (end - start) * 1e-9 + " sec.");
		System.out.println();
		//다른 방법2 - 열의 가운데까지 찍고 오른쪽에 나머지 별을 찍는다.
		//대신, 내부 반복문 한 개에서 처리하는 것이 아니라 먼저 별을 안 찍는 내부 반복문1을 수행한 후 별을 찍는 내부 반복문2를 순차 수행하도록 한다.
		//열1부터 살펴보면, 별이 안 찍히는 부분이 먼저 오고, 그 후에 별이 찍히게 때문에 내부 반복문 1, 2로 나누는 것이다.
		start = System.nanoTime();
		for (int i = 1; i <= 4; i++) {
//			for (int j = 1; j <= 7;) { //종료 조건을 상수로 확정짓는 것이 아닌
			for (int j = 1; j <= 4 - i; j++) {
				System.out.print(" ");
				System.out.print(" ");
			}
			for (int j = 4 - i + 1; j <= 4 + (i - 1); j++) { //j값을 별이 찍힐 열의 인덱스로 생각하여 이런 식으로 조건을 주거나
//			for (int j = 0; j < i * 2 + 1; j++) { //아니면, j값을 행에 찍힐 별의 개수로 생각하여 이런 식으로 조건을 줄 수도 있다.
				System.out.print("*");
				System.out.print(" ");
			}
			System.out.println();
		}
		end = System.nanoTime();
		System.out.println("Test1 : " + (end - start) * 1e-9 + " sec.");
		
		
//		        *      
//		      * * *    
//		    * * * * *  
//		  * * * * * * *
//		    * * * * *  
//		      * * *    
//		        *      
		for (int i = 1; i <= 7; i++) {
			for (int j = 1; j <= 7; j++) {
				int nIdxFromCenterRow = 4 - i;
				if (nIdxFromCenterRow < 0) {
					nIdxFromCenterRow = -nIdxFromCenterRow;
				}
				if (j <= nIdxFromCenterRow || (8 - j) <= nIdxFromCenterRow) {
					System.out.print(" ");
				} else {
					System.out.print("*");
				}
//				System.out.print("*");
				if (j != 7) {
					System.out.print(" ");
				}
			}
			System.out.println();
		}
	}

# java-junior
1544. Make The String Great

1. 인접한 알파벳이 각각 대소문자로 같은 알파벳인지 확인
 - 방법 :
  1. 비교할 알파벳을 toUpperCase() or toLowerCase()를 통해 같은 알파벳인지 판별 >> 같은 알파벳일지라도 대소문자가 변환되어 같은 것인지 변환되지 않고 모두 대문자 혹은 소문자로 같은 것인지 판별(변환 전 값과 변환 후 값 비교가 필요)
  2. 알파벳의 아스키 코드 값으로 알파벳 종류와 대소문자를 판별 + 같은 알파벳의 아스키 코드 값 차이는 32로 동일하므로 인접한 알파벳 아스키 코드 값 차이가 32인지 확인
 - 인접한 알파벳을 비교하는 방법
  1. for문
 
2. 같은 알파벳일 경우 두 알파벳을 문자열에서 제거
 - 방법 :
  1. String.substring한 값을 다시 String에 대입
  2. List에 제거 대상이 아닌 알파벳을 add하여 결과 값을 String으로 만듦(for문 필요)

*시나리오를 나눌 수 있는 방법
Input: s = "abBAcC"
Output: ""
Explanation: We have many possible scenarios, and all lead to the same answer. For example:
"abBAcC" --> "aAcC" --> "cC" --> ""
"abBAcC" --> "abBA" --> "aA" --> ""
 - 인접한 알파벳을 비교하는 방향을 어디에서부터 찾아나가는지에 따라 시나리오가 나뉘는 것으로 보인다. 방법의 차이는 아니라고 생각한다.

테스트 결과
 - 실패 1
  원인 : 문자열 제거 후 남은 앞의 알파벳과 뒤의 알파벳을 비교하는 로직을 고려하지 않았다. 즉, 현재 로직으로는 비교하고자 하는 알파벳이 통과할 경우 문자열 제거 후 새롭게 인접하게 된 알파벳과 새로 비교하는 로직이 누락되어 있다.
   - 방법 :
    1. 알파벳을 비교하는 for문을 완료한 후 알파벳이 제거된 새로운 결과가 나올 경우 다시 비교 for문을 수행한다. >> 문제 : 제거가 계속 수행되는 for문일 경우 반복문 수행을 계속 호출할 필요가 있는 재귀의 시간 복잡도를 갖게 된다.
	2. 문자열 제거가 일어난 시점에 새로 인접하게 될 두 알파벳을 비교한다.
	 2.1. i와 i+1의 알파벳이 제거됐을 경우 해당 시점의 i-1과 i+2를 비교한다. >> 문제 : 인접하게 될 알파벳이 계속해서 제거가 필요한 경우 마찬가지로 재귀의 시간 복잡도를 갖게 된다.
	 2.2. 문자열 제거 후 앞 문자열과 뒤 문자열을 합쳐 리턴한 문자열 s에서 제자리로 돌아와 반복문을 수행하는 것이 아닌 하나 이전의 인덱스에서 다시 비교를 시작한다. >> 반복문 수행 횟수는 경우에 따라 무한으로 늘어날 수 있지만 중첩이 아닌 단일한 반복문을 수행하므로 복잡도를 낮출 수 있을 것이다.
   
class Solution {
	public String makeGood(String s) {
		for (int i = 0; i <= s.length() - 2; i++) {
			char[] ca = s.toCharArray();
			int nAsciiCodeDiffVal = (char)ca[i] - (char)ca[i + 1];
			//수정1
			//굳이 char 배열 변수를 할당할 필요가 있을까?
//			nAsciiCodeDiffVal = s.substring(i, i + 1) - s.substring(i + 1, i + 2);
			//char 배열이 더 효율적으로 보임
			//아스키 코드 값으로 변환하기 위해서는 char형변환이 필요하며, substring의 경우 인덱스 오류 방지를 위해 조건문이 추가로 필요할 것으로 보이기 때문이다.
			if (nAsciiCodeDiffVal == 32 || nAsciiCodeDiffVal == -32) {
				//substring 인덱스 오류 방지
				String sFront = i == 0 ? "" : s.substring(0, i);
				String sBack = i == s.length() - 2 ? "" : s.substring(i + 2);
				//s에 다시 초기화하여도 새로운 s에 대해 새로운 인덱스로 반복문을 수행하기 때문에 새로운 변수에 할당할 필요가 없다.
				s = sFront + sBack;
//				System.out.println("i : " + i + ", s : " + s);
				//자른 문자열에 대해 현재 인덱스에서 다시 한 번 로직 수행
				//수정1
				//새로 인접할 알파벳(자르고 남은 앞 문자열의 마지막 알파벳과 뒷 문자열의 첫 알파벳) 간의 비교를 위해 한 칸 앞의 인덱스에서 다시 비교를 시작한다.
				//문자열 s의 첫 알파벳일 경우에는 앞 문자열이 없으므로 제자리로 돌아간다.
				i = i == 0 ? i - 1 : i - 2;
			}
		}
		
		return s;
	}
}


1. Two Sum
해석 : 주어지는 값은 정수 배열인 nums와 정수인 target.
결과는 인덱스를 반환하며, 해당 인덱스에 위치한 숫자를 합했을 때 target 값이 되도록하는 결과 값을 찾는다.
솔루션은 하나만 존재한다고 가정하며, 동일한 요소를 두 번 사용할 수는 없다.

제약 사항:
2 <= nums.length <= 104
-109 <= nums[i] <= 109
-109 <= target <= 109
Only one valid answer exists.

방법
1. nums 배열에서 두 요소를 추출한 경우의 수에서 그 합이 target 값과 일치하는 결과를 찾는다.
 - nums.length 최대값은 104로 최대 경우의 수는 104*103의 중첩 반복문이 발생할 수 있다.

2. 어떠한 두 수를 더해 target 값이 되는 경우의 수에서 해당 두 수가 nums 배열 요소로 존재하는지를 찾는다.
 - -109 <= target <= 109이 target의 범위
 target 최소값 -109는 nums[i] 범위에 따라 최소 -109와 최대 0의 범위 내의 수의 합
            -108은 최소 -109와 최대 1의 범위 내의 수의 합
			...
			0은 최소 -109와 최대 109의 범위 내의 수의 합
		최대값 109는 최소 0과 최대 109의 범위 내의 수의 합으로 만들어진다.
 따라서 target이 0이 될 때 두 수의 경우의 수가 최대가 되며, 경우의 수는 -109+109부터 0+0까지 110가지이다.
 하지만, target의 경우의 수를 도출할 시작과 끝이 target 값에 따라 변동되어 반복 조건을 거는 것이 쉽지 않다.
 
흐름도(순서도)를 생각해 보자!
조건 : nums[i] + nums[j] = target?
 - Yes : return [i, j] or [j, i]
 - No : 조건문 재실행(반복)
 
조건문에 대입할 i와 j를 추출하는 방법
1. 일단 nums 배열에서 i와 j를 추출할 수 있는 모든 경우의 수로 작성해보자.

A really brute force way would be to search for all possible pairs of numbers but that would be too slow. Again, it's best to try out brute force solutions for just for completeness. It is from these brute force solutions that you can come up with optimizations.
So, if we fix one of the numbers, say x, we have to scan the entire array to find the next number y which is value - x where value is the input parameter. Can we change our array somehow so that this search becomes faster?
The second train of thought is, without changing the array, can we use additional space somehow? Like maybe a hash map to speed up the search?

public static void ComplementNumber()
	{
		int[] nums = {2, 7, 11, 15};
		int target = 9;
		
		long start = System.nanoTime();
		
		int[] output = new int[2];
		boolean flag = false;
		
		for (int i = 0; i < nums.length - 1; i++) {
			//nums[i] 값이 결정
			//i에 대한 output의 보수는 유일하며, 그 결과도 유일하다고 가정되었기 때문에
			//i에 해당하는 j 역시 결정된 것이다.
			//따라서 j가 nums의 요소인지만 확인하면 된다.
			//답변2로 구현해보자!
			for (int j = i + 1; j < nums.length; j++) {
				if (nums[i] + nums[j] == target) {
					output[0] = i;
					output[1] = j;
					flag = true;
					break;
				}
			}
			if (flag) {
				break;
			}
		}
		System.out.println("Output: [" + output[0] + "," + output[1] + "]");
		
		long end = System.nanoTime();
		System.out.println("Test: " + (end - start) * 1e-9 + " sec.");
		
		start = System.nanoTime();
		
		output = new int[nums.length];
		int num2 = 0;
		Integer[] nums2 = new Integer[nums.length];
		for (int i = 0; i < nums.length; i++) {
			nums2[i] = nums[i];
		}
		
		for (int i = 0; i < nums.length - 1; i++) {
			//답변2
			int num1 = nums[i];
			num2 = target - num1;
//			System.out.println(num1);
//			System.out.println(num2);
//			System.out.println(Arrays.asList(nums2).contains(num2));
			//int[]을 asList할 경우 primitive 타입을 자동 형변환해주지 않기 때문에 List<int[]> 타입을 리턴한다.
			//원하는 결과값을 얻기 위해서는 Integer[]을 asList 메소드에 넘겨주어야 한다.
			if ((num2 >= -1000000000 && num2 <= 1000000000) && Arrays.asList(nums2).contains(num2)) {
				output[0] = i;
				break;
			}
		}
		for (int i = output[0] + 1; i < nums.length; i++) {
			if (nums[i] == num2) {
				output[1] = i;
				break;
			}
		}
		//num1 값(정확히 말하면 num1 값에 대한 target의 보수인 num2 값)과 인덱스를 별도의 map 변수에 저장하여
		//하나의 for문 안에서 해당 num1에 대한 num2 값이 nums 배열에 있는지 확인할 수 있다.
		//이를 적용하여 답변3을 작성해보자.
		
		System.out.println("Output: [" + output[0] + "," + output[1] + "]");
		
		end = System.nanoTime();
		System.out.println("Test: " + (end - start) * 1e-9 + " sec.");
		
		start = System.nanoTime();
		
		output = new int[nums.length];
		HashMap<Integer, Integer> hmOutput = new HashMap<Integer, Integer>();
		
		for (int i = 0; i < nums.length; i++) {
			//결과(보수 값과 인덱스) map 넣기
			hmOutput.put(target - nums[i], i);
			
			//map에서 현재 num가 존재하는지 찾기
			if (i > 0) {
				if (hmOutput.containsKey(nums[i]) && hmOutput.get(nums[i]) != i) {	//자기 자신(숫자가 아닌 인덱스로)을 보수로 갖는 경우를 제외(두 번 사용하지 않는다고 했기 때문에)
					output[0] = hmOutput.get(nums[i]);
					output[1] = i;
					break;
				}
			}
			//순서를 바꾸면 조건을 줄일 수 있다.
			//먼저 찾고 나중에 넣으면 자기 자신을 제외해야 하는 조건을 주지 않아도 된다.
			
			//현재 인덱스를 기준으로
			//지난 인덱스의 value와 비교하는 것이다.
			//즉, 0번째 인덱스는 비교 대상이 없으니 수행하지 않고, 1번째 인덱스는 0번째 인덱스 값과 비교, 2번째 인덱스는 1,2번째 인덱스 값과 비교해가는 식이다.
			//for문이 전체 수행된다면, 모든 경우의 수에 대해 비교가 가능한 것이다.
		}
		
		System.out.println("Output: [" + output[0] + "," + output[1] + "]");
		end = System.nanoTime();
		System.out.println("Test: " + (end - start) * 1e-9 + " sec.");
		//추가 고려 사항
		//범위 제약 사항에 따라 변수를 int가 아닌 long 타입으로 선언해야할 수도 있다.
	}


20. Valid Parentheses
Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Every close bracket has a corresponding open bracket of the same type.
